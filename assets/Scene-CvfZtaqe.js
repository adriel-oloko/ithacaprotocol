import{c as ps,i as Lt,n as on,e as an,a as ms,b as cn,d as ln,f as gs,v as un,g as xt,h as fn,j as dn,k as st,r as g,M as hn,u as Bs,l as An,T as pn,m as Tt,o as vs,R as Ke,L as Cs,p as _e,F as nt,C as ie,S as mn,P as gn,D as Bn,q as Le,s as $,V as N,t as V,I as vn,w as Cn,O as Ms,x as Mn,y as En,B as ce,z as xn,A as me,E as Es,G as St,H as xs,J as Je,K as Tn,N as Ts,Q as be,U as Sn,W as ke,X as yn,Y as Qe,Z as Rn,_ as bn,$ as Fn,a0 as Gt,a1 as Ne,a2 as Ss,a3 as pe,a4 as Dn,a5 as In,a6 as Gn,a7 as wn,a8 as ys,a9 as Ie,aa as Rs,ab as ze,ac as Pn,ad as Hn,ae as Un,af as On,ag as Ln,ah as _n,ai as bs,aj as Jn,ak as it,al as _t,am as Jt,an as Nt,ao as Nn,ap as Fs,aq as zn,ar as wt,as as z,at as se,au as Ds,av as Is,aw as Gs,ax as q,ay as ge,az as yt,aA as Kn,aB as ws,aC as Fe,aD as kn,aE as ae,aF as y,aG as Xe,aH as xe,aI as k,aJ as Qn,aK as Xn,aL as jn,aM as Pt,aN as Ps,aO as Hs,aP as Ge,aQ as Vn,aR as qe,aS as ee,aT as w,aU as Te,aV as Yn,aW as zt,aX as Rt,aY as Wn,aZ as Ht,a_ as Zn}from"./index-BCy5xNdd.js";const Kt=t=>!!(t&&t.getVelocity),Us=t=>t*1e3,Ee=t=>t/1e3,qn=t=>Array.isArray(t)&&typeof t[0]!="number",Os=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,Ls=t=>e=>1-t(1-e),_s=t=>1-Math.sin(Math.acos(t)),Js=Ls(_s),$n=Os(Js),Ns=ps(.33,1.53,.69,.99),Ut=Ls(Ns),ei=Os(Ut),ti=t=>(t*=2)<1?.5*Ut(t):.5*(2-Math.pow(2,-10*(t-1))),kt={linear:on,easeIn:an,easeInOut:ms,easeOut:cn,circIn:_s,circInOut:$n,circOut:Js,backIn:Ut,backInOut:ei,backOut:Ns,anticipate:ti},Qt=t=>{if(Array.isArray(t)){Lt(t.length===4);const[e,s,n,i]=t;return ps(e,s,n,i)}else if(typeof t=="string")return Lt(kt[t]!==void 0),kt[t];return t};function si(t,e){return t.map(s=>s*e)}function ni(t,e){return t.map(()=>e||ms).splice(0,t.length-1)}function rt({duration:t=300,keyframes:e,times:s,ease:n="easeInOut"}){const i=qn(n)?n.map(Qt):Qt(n),o={done:!1,value:e[0]},r=si(s&&s.length===e.length?s:ln(e),t),c=gs(r,e,{ease:Array.isArray(i)?i:ni(e,i)});return{calculatedDuration:t,next:a=>(o.value=c(a),o.done=a>=t,o)}}const ii=5;function zs(t,e,s){const n=Math.max(e-ii,0);return un(s-t(n),e-n)}const dt=.001,ri=.01,oi=10,ai=.05,ci=1;function li({duration:t=800,bounce:e=.25,velocity:s=0,mass:n=1}){let i,o,r=1-e;r=xt(ai,ci,r),t=xt(ri,oi,Ee(t)),r<1?(i=l=>{const u=l*r,f=u*t,d=u-s,h=bt(l,r),A=Math.exp(-f);return dt-d/h*A},o=l=>{const f=l*r*t,d=f*s+s,h=Math.pow(r,2)*Math.pow(l,2)*t,A=Math.exp(-f),m=bt(Math.pow(l,2),r);return(-i(l)+dt>0?-1:1)*((d-h)*A)/m}):(i=l=>{const u=Math.exp(-l*t),f=(l-s)*t+1;return-dt+u*f},o=l=>{const u=Math.exp(-l*t),f=(s-l)*(t*t);return u*f});const c=5/t,a=fi(i,o,c);if(t=Us(t),isNaN(a))return{stiffness:100,damping:10,duration:t};{const l=Math.pow(a,2)*n;return{stiffness:l,damping:r*2*Math.sqrt(n*l),duration:t}}}const ui=12;function fi(t,e,s){let n=s;for(let i=1;i<ui;i++)n=n-t(n)/e(n);return n}function bt(t,e){return t*Math.sqrt(1-e*e)}const di=["duration","bounce"],hi=["stiffness","damping","mass"];function Xt(t,e){return e.some(s=>t[s]!==void 0)}function Ai(t){let e={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...t};if(!Xt(t,hi)&&Xt(t,di)){const s=li(t);e={...e,...s,velocity:0,mass:1},e.isResolvedFromDuration=!0}return e}function Ks({keyframes:t,restDelta:e,restSpeed:s,...n}){const i=t[0],o=t[t.length-1],r={done:!1,value:i},{stiffness:c,damping:a,mass:l,velocity:u,duration:f,isResolvedFromDuration:d}=Ai(n),h=u?-Ee(u):0,A=a/(2*Math.sqrt(c*l)),m=o-i,p=Ee(Math.sqrt(c/l)),B=Math.abs(m)<5;s||(s=B?.01:2),e||(e=B?.005:.5);let v;if(A<1){const C=bt(p,A);v=M=>{const E=Math.exp(-A*p*M);return o-E*((h+A*p*m)/C*Math.sin(C*M)+m*Math.cos(C*M))}}else if(A===1)v=C=>o-Math.exp(-p*C)*(m+(h+p*m)*C);else{const C=p*Math.sqrt(A*A-1);v=M=>{const E=Math.exp(-A*p*M),S=Math.min(C*M,300);return o-E*((h+A*p*m)*Math.sinh(S)+C*m*Math.cosh(S))/C}}return{calculatedDuration:d&&f||null,next:C=>{const M=v(C);if(d)r.done=C>=f;else{let E=h;C!==0&&(A<1?E=zs(v,C,M):E=0);const S=Math.abs(E)<=s,R=Math.abs(o-M)<=e;r.done=S&&R}return r.value=r.done?o:M,r}}}function jt({keyframes:t,velocity:e=0,power:s=.8,timeConstant:n=325,bounceDamping:i=10,bounceStiffness:o=500,modifyTarget:r,min:c,max:a,restDelta:l=.5,restSpeed:u}){const f=t[0],d={done:!1,value:f},h=T=>c!==void 0&&T<c||a!==void 0&&T>a,A=T=>c===void 0?a:a===void 0||Math.abs(c-T)<Math.abs(a-T)?c:a;let m=s*e;const p=f+m,B=r===void 0?p:r(p);B!==p&&(m=B-f);const v=T=>-m*Math.exp(-T/n),C=T=>B+v(T),M=T=>{const b=v(T),G=C(T);d.done=Math.abs(b)<=l,d.value=d.done?B:G};let E,S;const R=T=>{h(d.value)&&(E=T,S=Ks({keyframes:[d.value,A(d.value)],velocity:zs(C,T,d.value),damping:i,stiffness:o,restDelta:l,restSpeed:u}))};return R(0),{calculatedDuration:null,next:T=>{let b=!1;return!S&&E===void 0&&(b=!0,M(T),R(T)),E!==void 0&&T>E?S.next(T-E):(!b&&M(T),d)}}}const pi=t=>{const e=({timestamp:s})=>t(s);return{start:()=>fn.update(e,!0),stop:()=>dn(e),now:()=>st.isProcessing?st.timestamp:performance.now()}},Vt=2e4;function Yt(t){let e=0;const s=50;let n=t.next(e);for(;!n.done&&e<Vt;)e+=s,n=t.next(e);return e>=Vt?1/0:e}const mi={decay:jt,inertia:jt,tween:rt,keyframes:rt,spring:Ks};function gi({autoplay:t=!0,delay:e=0,driver:s=pi,keyframes:n,type:i="keyframes",repeat:o=0,repeatDelay:r=0,repeatType:c="loop",onPlay:a,onStop:l,onComplete:u,onUpdate:f,...d}){let h=1,A=!1,m,p;const B=()=>{p=new Promise(H=>{m=H})};B();let v;const C=mi[i]||rt;let M;C!==rt&&typeof n[0]!="number"&&(M=gs([0,100],n,{clamp:!1}),n=[0,100]);const E=C({...d,keyframes:n});let S;c==="mirror"&&(S=C({...d,keyframes:[...n].reverse(),velocity:-(d.velocity||0)}));let R="idle",T=null,b=null,G=null;E.calculatedDuration===null&&o&&(E.calculatedDuration=Yt(E));const{calculatedDuration:U}=E;let O=1/0,W=1/0;U!==null&&(O=U+r,W=O*(o+1)-r);let _=0;const re=H=>{if(b===null)return;h>0&&(b=Math.min(b,H)),h<0&&(b=Math.min(H-W/h,b)),T!==null?_=T:_=Math.round(H-b)*h;const L=_-e*(h>=0?1:-1),J=h>=0?L<0:L>W;_=Math.max(L,0),R==="finished"&&T===null&&(_=W);let P=_,te=E;if(o){const x=_/O;let j=Math.floor(x),ne=x%1;!ne&&x>=1&&(ne=1),ne===1&&j--,j=Math.min(j,o+1);const Be=!!(j%2);Be&&(c==="reverse"?(ne=1-ne,r&&(ne-=r/O)):c==="mirror"&&(te=S));let ut=xt(0,1,ne);_>W&&(ut=c==="reverse"&&Be?1:0),P=ut*O}const X=J?{done:!1,value:n[0]}:te.next(P);M&&(X.value=M(X.value));let{done:Se}=X;!J&&U!==null&&(Se=h>=0?_>=W:_<=0);const ye=T===null&&(R==="finished"||R==="running"&&Se);return f&&f(X.value),ye&&lt(),X},K=()=>{v&&v.stop(),v=void 0},fe=()=>{R="idle",K(),m(),B(),b=G=null},lt=()=>{R="finished",u&&u(),K(),m()},We=()=>{if(A)return;v||(v=s(re));const H=v.now();a&&a(),T!==null?b=H-T:(!b||R==="finished")&&(b=H),R==="finished"&&B(),G=b,T=null,R="running",v.start()};t&&We();const Ze={then(H,L){return p.then(H,L)},get time(){return Ee(_)},set time(H){H=Us(H),_=H,T!==null||!v||h===0?T=H:b=v.now()-H/h},get duration(){const H=E.calculatedDuration===null?Yt(E):E.calculatedDuration;return Ee(H)},get speed(){return h},set speed(H){H===h||!v||(h=H,Ze.time=Ee(_))},get state(){return R},play:We,pause:()=>{R="paused",T=_},stop:()=>{A=!0,R!=="idle"&&(R="idle",l&&l(),fe())},cancel:()=>{G!==null&&re(G),fe()},complete:()=>{R="finished"},sample:H=>(b=0,re(H))};return Ze}function Bi(t,e={}){const{isStatic:s}=g.useContext(hn),n=g.useRef(null),i=Bs(Kt(t)?t.get():t),o=()=>{n.current&&n.current.stop()};return g.useInsertionEffect(()=>i.attach((r,c)=>{if(s)return c(r);if(o(),n.current=gi({keyframes:[i.get(),r],velocity:i.getVelocity(),type:"spring",restDelta:.001,restSpeed:.01,...e,onUpdate:c}),!st.isProcessing){const a=performance.now()-st.timestamp;a<30&&(n.current.time=Ee(a))}return i.get()},o),[JSON.stringify(e)]),An(()=>{if(Kt(t))return t.on("change",r=>i.set(parseFloat(r)))},[i]),i}function je(t){return function(e){t.forEach(function(s){typeof s=="function"?s(e):s!=null&&(s.current=e)})}}function Wt(t,e){if(e===pn)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(e===Tt||e===vs){let s=t.getIndex();if(s===null){const r=[],c=t.getAttribute("position");if(c!==void 0){for(let a=0;a<c.count;a++)r.push(a);t.setIndex(r),s=t.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}const n=s.count-2,i=[];if(s)if(e===Tt)for(let r=1;r<=n;r++)i.push(s.getX(0)),i.push(s.getX(r)),i.push(s.getX(r+1));else for(let r=0;r<n;r++)r%2===0?(i.push(s.getX(r)),i.push(s.getX(r+1)),i.push(s.getX(r+2))):(i.push(s.getX(r+2)),i.push(s.getX(r+1)),i.push(s.getX(r)));i.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const o=t.clone();return o.setIndex(i),o.clearGroups(),o}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}const vi=parseInt(Ke.replace(/\D+/g,""));function ot(t){if(typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let s=0,n=t.length;s<n;s++)e+=String.fromCharCode(t[s]);try{return decodeURIComponent(escape(e))}catch{return e}}const Me="srgb",le="srgb-linear",Zt=3001,Ci=3e3;class Ot extends Cs{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(s){return new Si(s)}),this.register(function(s){return new yi(s)}),this.register(function(s){return new Hi(s)}),this.register(function(s){return new Ui(s)}),this.register(function(s){return new Oi(s)}),this.register(function(s){return new bi(s)}),this.register(function(s){return new Fi(s)}),this.register(function(s){return new Di(s)}),this.register(function(s){return new Ii(s)}),this.register(function(s){return new Ti(s)}),this.register(function(s){return new Gi(s)}),this.register(function(s){return new Ri(s)}),this.register(function(s){return new Pi(s)}),this.register(function(s){return new wi(s)}),this.register(function(s){return new Ei(s)}),this.register(function(s){return new Li(s)}),this.register(function(s){return new _i(s)})}load(e,s,n,i){const o=this;let r;if(this.resourcePath!=="")r=this.resourcePath;else if(this.path!==""){const l=_e.extractUrlBase(e);r=_e.resolveURL(l,this.path)}else r=_e.extractUrlBase(e);this.manager.itemStart(e);const c=function(l){i?i(l):console.error(l),o.manager.itemError(e),o.manager.itemEnd(e)},a=new nt(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){try{o.parse(l,r,function(u){s(u),o.manager.itemEnd(e)},c)}catch(u){c(u)}},n,c)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,s,n,i){let o;const r={},c={};if(typeof e=="string")o=JSON.parse(e);else if(e instanceof ArrayBuffer)if(ot(new Uint8Array(e.slice(0,4)))===ks){try{r[D.KHR_BINARY_GLTF]=new Ji(e)}catch(u){i&&i(u);return}o=JSON.parse(r[D.KHR_BINARY_GLTF].content)}else o=JSON.parse(ot(new Uint8Array(e)));else o=e;if(o.asset===void 0||o.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const a=new $i(o,{path:s||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});a.fileLoader.setRequestHeader(this.requestHeader);for(let l=0;l<this.pluginCallbacks.length;l++){const u=this.pluginCallbacks[l](a);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),c[u.name]=u,r[u.name]=!0}if(o.extensionsUsed)for(let l=0;l<o.extensionsUsed.length;++l){const u=o.extensionsUsed[l],f=o.extensionsRequired||[];switch(u){case D.KHR_MATERIALS_UNLIT:r[u]=new xi;break;case D.KHR_DRACO_MESH_COMPRESSION:r[u]=new Ni(o,this.dracoLoader);break;case D.KHR_TEXTURE_TRANSFORM:r[u]=new zi;break;case D.KHR_MESH_QUANTIZATION:r[u]=new Ki;break;default:f.indexOf(u)>=0&&c[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}a.setExtensions(r),a.setPlugins(c),a.parse(n,i)}parseAsync(e,s){const n=this;return new Promise(function(i,o){n.parse(e,s,i,o)})}}function Mi(){let t={};return{get:function(e){return t[e]},add:function(e,s){t[e]=s},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const D={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Ei{constructor(e){this.parser=e,this.name=D.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,s=this.parser.json.nodes||[];for(let n=0,i=s.length;n<i;n++){const o=s[n];o.extensions&&o.extensions[this.name]&&o.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,o.extensions[this.name].light)}}_loadLight(e){const s=this.parser,n="light:"+e;let i=s.cache.get(n);if(i)return i;const o=s.json,a=((o.extensions&&o.extensions[this.name]||{}).lights||[])[e];let l;const u=new ie(16777215);a.color!==void 0&&u.setRGB(a.color[0],a.color[1],a.color[2],le);const f=a.range!==void 0?a.range:0;switch(a.type){case"directional":l=new Bn(u),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new gn(u),l.distance=f;break;case"spot":l=new mn(u),l.distance=f,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,l.angle=a.spot.outerConeAngle,l.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return l.position.set(0,0,0),l.decay=2,oe(l,a),a.intensity!==void 0&&(l.intensity=a.intensity),l.name=s.createUniqueName(a.name||"light_"+e),i=Promise.resolve(l),s.cache.add(n,i),i}getDependency(e,s){if(e==="light")return this._loadLight(s)}createNodeAttachment(e){const s=this,n=this.parser,o=n.json.nodes[e],c=(o.extensions&&o.extensions[this.name]||{}).light;return c===void 0?null:this._loadLight(c).then(function(a){return n._getNodeRef(s.cache,c,a)})}}class xi{constructor(){this.name=D.KHR_MATERIALS_UNLIT}getMaterialType(){return Le}extendParams(e,s,n){const i=[];e.color=new ie(1,1,1),e.opacity=1;const o=s.pbrMetallicRoughness;if(o){if(Array.isArray(o.baseColorFactor)){const r=o.baseColorFactor;e.color.setRGB(r[0],r[1],r[2],le),e.opacity=r[3]}o.baseColorTexture!==void 0&&i.push(n.assignTexture(e,"map",o.baseColorTexture,Me))}return Promise.all(i)}}class Ti{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,s){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=i.extensions[this.name].emissiveStrength;return o!==void 0&&(s.emissiveIntensity=o),Promise.resolve()}}class Si{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[],r=i.extensions[this.name];if(r.clearcoatFactor!==void 0&&(s.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&o.push(n.assignTexture(s,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(s.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&o.push(n.assignTexture(s,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(o.push(n.assignTexture(s,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const c=r.clearcoatNormalTexture.scale;s.clearcoatNormalScale=new N(c,c)}return Promise.all(o)}}class yi{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_DISPERSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=i.extensions[this.name];return s.dispersion=o.dispersion!==void 0?o.dispersion:0,Promise.resolve()}}class Ri{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[],r=i.extensions[this.name];return r.iridescenceFactor!==void 0&&(s.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&o.push(n.assignTexture(s,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(s.iridescenceIOR=r.iridescenceIor),s.iridescenceThicknessRange===void 0&&(s.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(s.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(s.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&o.push(n.assignTexture(s,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(o)}}class bi{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[];s.sheenColor=new ie(0,0,0),s.sheenRoughness=0,s.sheen=1;const r=i.extensions[this.name];if(r.sheenColorFactor!==void 0){const c=r.sheenColorFactor;s.sheenColor.setRGB(c[0],c[1],c[2],le)}return r.sheenRoughnessFactor!==void 0&&(s.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&o.push(n.assignTexture(s,"sheenColorMap",r.sheenColorTexture,Me)),r.sheenRoughnessTexture!==void 0&&o.push(n.assignTexture(s,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(o)}}class Fi{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[],r=i.extensions[this.name];return r.transmissionFactor!==void 0&&(s.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&o.push(n.assignTexture(s,"transmissionMap",r.transmissionTexture)),Promise.all(o)}}class Di{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[],r=i.extensions[this.name];s.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&o.push(n.assignTexture(s,"thicknessMap",r.thicknessTexture)),s.attenuationDistance=r.attenuationDistance||1/0;const c=r.attenuationColor||[1,1,1];return s.attenuationColor=new ie().setRGB(c[0],c[1],c[2],le),Promise.all(o)}}class Ii{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=i.extensions[this.name];return s.ior=o.ior!==void 0?o.ior:1.5,Promise.resolve()}}class Gi{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[],r=i.extensions[this.name];s.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&o.push(n.assignTexture(s,"specularIntensityMap",r.specularTexture));const c=r.specularColorFactor||[1,1,1];return s.specularColor=new ie().setRGB(c[0],c[1],c[2],le),r.specularColorTexture!==void 0&&o.push(n.assignTexture(s,"specularColorMap",r.specularColorTexture,Me)),Promise.all(o)}}class wi{constructor(e){this.parser=e,this.name=D.EXT_MATERIALS_BUMP}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[],r=i.extensions[this.name];return s.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1,r.bumpTexture!==void 0&&o.push(n.assignTexture(s,"bumpMap",r.bumpTexture)),Promise.all(o)}}class Pi{constructor(e){this.parser=e,this.name=D.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:$}extendMaterialParams(e,s){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const o=[],r=i.extensions[this.name];return r.anisotropyStrength!==void 0&&(s.anisotropy=r.anisotropyStrength),r.anisotropyRotation!==void 0&&(s.anisotropyRotation=r.anisotropyRotation),r.anisotropyTexture!==void 0&&o.push(n.assignTexture(s,"anisotropyMap",r.anisotropyTexture)),Promise.all(o)}}class Hi{constructor(e){this.parser=e,this.name=D.KHR_TEXTURE_BASISU}loadTexture(e){const s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const o=i.extensions[this.name],r=s.options.ktx2Loader;if(!r){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return s.loadTextureImage(e,o.source,r)}}class Ui{constructor(e){this.parser=e,this.name=D.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const s=this.name,n=this.parser,i=n.json,o=i.textures[e];if(!o.extensions||!o.extensions[s])return null;const r=o.extensions[s],c=i.images[r.source];let a=n.textureLoader;if(c.uri){const l=n.options.manager.getHandler(c.uri);l!==null&&(a=l)}return this.detectSupport().then(function(l){if(l)return n.loadTextureImage(e,r.source,a);if(i.extensionsRequired&&i.extensionsRequired.indexOf(s)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const s=new Image;s.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",s.onload=s.onerror=function(){e(s.height===1)}})),this.isSupported}}class Oi{constructor(e){this.parser=e,this.name=D.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const s=this.name,n=this.parser,i=n.json,o=i.textures[e];if(!o.extensions||!o.extensions[s])return null;const r=o.extensions[s],c=i.images[r.source];let a=n.textureLoader;if(c.uri){const l=n.options.manager.getHandler(c.uri);l!==null&&(a=l)}return this.detectSupport().then(function(l){if(l)return n.loadTextureImage(e,r.source,a);if(i.extensionsRequired&&i.extensionsRequired.indexOf(s)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const s=new Image;s.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",s.onload=s.onerror=function(){e(s.height===1)}})),this.isSupported}}class Li{constructor(e){this.name=D.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const s=this.parser.json,n=s.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const i=n.extensions[this.name],o=this.parser.getDependency("buffer",i.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return o.then(function(c){const a=i.byteOffset||0,l=i.byteLength||0,u=i.count,f=i.byteStride,d=new Uint8Array(c,a,l);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(u,f,d,i.mode,i.filter).then(function(h){return h.buffer}):r.ready.then(function(){const h=new ArrayBuffer(u*f);return r.decodeGltfBuffer(new Uint8Array(h),u,f,d,i.mode,i.filter),h})})}else return null}}class _i{constructor(e){this.name=D.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const s=this.parser.json,n=s.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const i=s.meshes[n.mesh];for(const l of i.primitives)if(l.mode!==Z.TRIANGLES&&l.mode!==Z.TRIANGLE_STRIP&&l.mode!==Z.TRIANGLE_FAN&&l.mode!==void 0)return null;const r=n.extensions[this.name].attributes,c=[],a={};for(const l in r)c.push(this.parser.getDependency("accessor",r[l]).then(u=>(a[l]=u,a[l])));return c.length<1?null:(c.push(this.parser.createNodeMesh(e)),Promise.all(c).then(l=>{const u=l.pop(),f=u.isGroup?u.children:[u],d=l[0].count,h=[];for(const A of f){const m=new Ie,p=new V,B=new Rs,v=new V(1,1,1),C=new vn(A.geometry,A.material,d);for(let M=0;M<d;M++)a.TRANSLATION&&p.fromBufferAttribute(a.TRANSLATION,M),a.ROTATION&&B.fromBufferAttribute(a.ROTATION,M),a.SCALE&&v.fromBufferAttribute(a.SCALE,M),C.setMatrixAt(M,m.compose(p,B,v));for(const M in a)if(M==="_COLOR_0"){const E=a[M];C.instanceColor=new Cn(E.array,E.itemSize,E.normalized)}else M!=="TRANSLATION"&&M!=="ROTATION"&&M!=="SCALE"&&A.geometry.setAttribute(M,a[M]);Ms.prototype.copy.call(C,A),this.parser.assignFinalMaterial(C),h.push(C)}return u.isGroup?(u.clear(),u.add(...h),u):h[0]}))}}const ks="glTF",Pe=12,qt={JSON:1313821514,BIN:5130562};class Ji{constructor(e){this.name=D.KHR_BINARY_GLTF,this.content=null,this.body=null;const s=new DataView(e,0,Pe);if(this.header={magic:ot(new Uint8Array(e.slice(0,4))),version:s.getUint32(4,!0),length:s.getUint32(8,!0)},this.header.magic!==ks)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Pe,i=new DataView(e,Pe);let o=0;for(;o<n;){const r=i.getUint32(o,!0);o+=4;const c=i.getUint32(o,!0);if(o+=4,c===qt.JSON){const a=new Uint8Array(e,Pe+o,r);this.content=ot(a)}else if(c===qt.BIN){const a=Pe+o;this.body=e.slice(a,a+r)}o+=r}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Ni{constructor(e,s){if(!s)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=D.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=s,this.dracoLoader.preload()}decodePrimitive(e,s){const n=this.json,i=this.dracoLoader,o=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,c={},a={},l={};for(const u in r){const f=Ft[u]||u.toLowerCase();c[f]=r[u]}for(const u in e.attributes){const f=Ft[u]||u.toLowerCase();if(r[u]!==void 0){const d=n.accessors[e.attributes[u]],h=De[d.componentType];l[f]=h.name,a[f]=d.normalized===!0}}return s.getDependency("bufferView",o).then(function(u){return new Promise(function(f,d){i.decodeDracoFile(u,function(h){for(const A in h.attributes){const m=h.attributes[A],p=a[A];p!==void 0&&(m.normalized=p)}f(h)},c,l,le,d)})})}}class zi{constructor(){this.name=D.KHR_TEXTURE_TRANSFORM}extendTexture(e,s){return(s.texCoord===void 0||s.texCoord===e.channel)&&s.offset===void 0&&s.rotation===void 0&&s.scale===void 0||(e=e.clone(),s.texCoord!==void 0&&(e.channel=s.texCoord),s.offset!==void 0&&e.offset.fromArray(s.offset),s.rotation!==void 0&&(e.rotation=s.rotation),s.scale!==void 0&&e.repeat.fromArray(s.scale),e.needsUpdate=!0),e}}class Ki{constructor(){this.name=D.KHR_MESH_QUANTIZATION}}class Qs extends zn{constructor(e,s,n,i){super(e,s,n,i)}copySampleValue_(e){const s=this.resultBuffer,n=this.sampleValues,i=this.valueSize,o=e*i*3+i;for(let r=0;r!==i;r++)s[r]=n[o+r];return s}interpolate_(e,s,n,i){const o=this.resultBuffer,r=this.sampleValues,c=this.valueSize,a=c*2,l=c*3,u=i-s,f=(n-s)/u,d=f*f,h=d*f,A=e*l,m=A-l,p=-2*h+3*d,B=h-d,v=1-p,C=B-d+f;for(let M=0;M!==c;M++){const E=r[m+M+c],S=r[m+M+a]*u,R=r[A+M+c],T=r[A+M]*u;o[M]=v*E+C*S+p*R+B*T}return o}}const ki=new Rs;class Qi extends Qs{interpolate_(e,s,n,i){const o=super.interpolate_(e,s,n,i);return ki.fromArray(o).normalize().toArray(o),o}}const Z={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},De={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},$t={9728:ze,9729:me,9984:Pn,9985:Hn,9986:Un,9987:Es},es={33071:On,33648:Ln,10497:St},ht={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Ft={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...vi>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},de={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Xi={CUBICSPLINE:void 0,LINEAR:ys,STEP:_n},At={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function ji(t){return t.DefaultMaterial===void 0&&(t.DefaultMaterial=new Ts({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:bs})),t.DefaultMaterial}function ve(t,e,s){for(const n in s.extensions)t[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=s.extensions[n])}function oe(t,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(t.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Vi(t,e,s){let n=!1,i=!1,o=!1;for(let l=0,u=e.length;l<u;l++){const f=e[l];if(f.POSITION!==void 0&&(n=!0),f.NORMAL!==void 0&&(i=!0),f.COLOR_0!==void 0&&(o=!0),n&&i&&o)break}if(!n&&!i&&!o)return Promise.resolve(t);const r=[],c=[],a=[];for(let l=0,u=e.length;l<u;l++){const f=e[l];if(n){const d=f.POSITION!==void 0?s.getDependency("accessor",f.POSITION):t.attributes.position;r.push(d)}if(i){const d=f.NORMAL!==void 0?s.getDependency("accessor",f.NORMAL):t.attributes.normal;c.push(d)}if(o){const d=f.COLOR_0!==void 0?s.getDependency("accessor",f.COLOR_0):t.attributes.color;a.push(d)}}return Promise.all([Promise.all(r),Promise.all(c),Promise.all(a)]).then(function(l){const u=l[0],f=l[1],d=l[2];return n&&(t.morphAttributes.position=u),i&&(t.morphAttributes.normal=f),o&&(t.morphAttributes.color=d),t.morphTargetsRelative=!0,t})}function Yi(t,e){if(t.updateMorphTargets(),e.weights!==void 0)for(let s=0,n=e.weights.length;s<n;s++)t.morphTargetInfluences[s]=e.weights[s];if(e.extras&&Array.isArray(e.extras.targetNames)){const s=e.extras.targetNames;if(t.morphTargetInfluences.length===s.length){t.morphTargetDictionary={};for(let n=0,i=s.length;n<i;n++)t.morphTargetDictionary[s[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Wi(t){let e;const s=t.extensions&&t.extensions[D.KHR_DRACO_MESH_COMPRESSION];if(s?e="draco:"+s.bufferView+":"+s.indices+":"+pt(s.attributes):e=t.indices+":"+pt(t.attributes)+":"+t.mode,t.targets!==void 0)for(let n=0,i=t.targets.length;n<i;n++)e+=":"+pt(t.targets[n]);return e}function pt(t){let e="";const s=Object.keys(t).sort();for(let n=0,i=s.length;n<i;n++)e+=s[n]+":"+t[s[n]]+";";return e}function Dt(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Zi(t){return t.search(/\.jpe?g($|\?)/i)>0||t.search(/^data\:image\/jpeg/)===0?"image/jpeg":t.search(/\.webp($|\?)/i)>0||t.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const qi=new Ie;class $i{constructor(e={},s={}){this.json=e,this.extensions={},this.plugins={},this.options=s,this.cache=new Mi,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,i=!1,o=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(n=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,o=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||n||i&&o<98?this.textureLoader=new Mn(this.options.manager):this.textureLoader=new En(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new nt(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,s){const n=this,i=this.json,o=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(r){const c={scene:r[0][i.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:i.asset,parser:n,userData:{}};return ve(o,c,i),oe(c,i),Promise.all(n._invokeAll(function(a){return a.afterRoot&&a.afterRoot(c)})).then(function(){for(const a of c.scenes)a.updateMatrixWorld();e(c)})}).catch(s)}_markDefs(){const e=this.json.nodes||[],s=this.json.skins||[],n=this.json.meshes||[];for(let i=0,o=s.length;i<o;i++){const r=s[i].joints;for(let c=0,a=r.length;c<a;c++)e[r[c]].isBone=!0}for(let i=0,o=e.length;i<o;i++){const r=e[i];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(n[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,s){s!==void 0&&(e.refs[s]===void 0&&(e.refs[s]=e.uses[s]=0),e.refs[s]++)}_getNodeRef(e,s,n){if(e.refs[s]<=1)return n;const i=n.clone(),o=(r,c)=>{const a=this.associations.get(r);a!=null&&this.associations.set(c,a);for(const[l,u]of r.children.entries())o(u,c.children[l])};return o(n,i),i.name+="_instance_"+e.uses[s]++,i}_invokeOne(e){const s=Object.values(this.plugins);s.push(this);for(let n=0;n<s.length;n++){const i=e(s[n]);if(i)return i}return null}_invokeAll(e){const s=Object.values(this.plugins);s.unshift(this);const n=[];for(let i=0;i<s.length;i++){const o=e(s[i]);o&&n.push(o)}return n}getDependency(e,s){const n=e+":"+s;let i=this.cache.get(n);if(!i){switch(e){case"scene":i=this.loadScene(s);break;case"node":i=this._invokeOne(function(o){return o.loadNode&&o.loadNode(s)});break;case"mesh":i=this._invokeOne(function(o){return o.loadMesh&&o.loadMesh(s)});break;case"accessor":i=this.loadAccessor(s);break;case"bufferView":i=this._invokeOne(function(o){return o.loadBufferView&&o.loadBufferView(s)});break;case"buffer":i=this.loadBuffer(s);break;case"material":i=this._invokeOne(function(o){return o.loadMaterial&&o.loadMaterial(s)});break;case"texture":i=this._invokeOne(function(o){return o.loadTexture&&o.loadTexture(s)});break;case"skin":i=this.loadSkin(s);break;case"animation":i=this._invokeOne(function(o){return o.loadAnimation&&o.loadAnimation(s)});break;case"camera":i=this.loadCamera(s);break;default:if(i=this._invokeOne(function(o){return o!=this&&o.getDependency&&o.getDependency(e,s)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(n,i)}return i}getDependencies(e){let s=this.cache.get(e);if(!s){const n=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];s=Promise.all(i.map(function(o,r){return n.getDependency(e,r)})),this.cache.add(e,s)}return s}loadBuffer(e){const s=this.json.buffers[e],n=this.fileLoader;if(s.type&&s.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+s.type+" buffer type is not supported.");if(s.uri===void 0&&e===0)return Promise.resolve(this.extensions[D.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(o,r){n.load(_e.resolveURL(s.uri,i.path),o,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+s.uri+'".'))})})}loadBufferView(e){const s=this.json.bufferViews[e];return this.getDependency("buffer",s.buffer).then(function(n){const i=s.byteLength||0,o=s.byteOffset||0;return n.slice(o,o+i)})}loadAccessor(e){const s=this,n=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const r=ht[i.type],c=De[i.componentType],a=i.normalized===!0,l=new c(i.count*r);return Promise.resolve(new ce(l,r,a))}const o=[];return i.bufferView!==void 0?o.push(this.getDependency("bufferView",i.bufferView)):o.push(null),i.sparse!==void 0&&(o.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(o).then(function(r){const c=r[0],a=ht[i.type],l=De[i.componentType],u=l.BYTES_PER_ELEMENT,f=u*a,d=i.byteOffset||0,h=i.bufferView!==void 0?n.bufferViews[i.bufferView].byteStride:void 0,A=i.normalized===!0;let m,p;if(h&&h!==f){const B=Math.floor(d/h),v="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+B+":"+i.count;let C=s.cache.get(v);C||(m=new l(c,B*h,i.count*h/u),C=new xn(m,h/u),s.cache.add(v,C)),p=new Jn(C,a,d%h/u,A)}else c===null?m=new l(i.count*a):m=new l(c,d,i.count*a),p=new ce(m,a,A);if(i.sparse!==void 0){const B=ht.SCALAR,v=De[i.sparse.indices.componentType],C=i.sparse.indices.byteOffset||0,M=i.sparse.values.byteOffset||0,E=new v(r[1],C,i.sparse.count*B),S=new l(r[2],M,i.sparse.count*a);c!==null&&(p=new ce(p.array.slice(),p.itemSize,p.normalized));for(let R=0,T=E.length;R<T;R++){const b=E[R];if(p.setX(b,S[R*a]),a>=2&&p.setY(b,S[R*a+1]),a>=3&&p.setZ(b,S[R*a+2]),a>=4&&p.setW(b,S[R*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return p})}loadTexture(e){const s=this.json,n=this.options,o=s.textures[e].source,r=s.images[o];let c=this.textureLoader;if(r.uri){const a=n.manager.getHandler(r.uri);a!==null&&(c=a)}return this.loadTextureImage(e,o,c)}loadTextureImage(e,s,n){const i=this,o=this.json,r=o.textures[e],c=o.images[s],a=(c.uri||c.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const l=this.loadImageSource(s,n).then(function(u){u.flipY=!1,u.name=r.name||c.name||"",u.name===""&&typeof c.uri=="string"&&c.uri.startsWith("data:image/")===!1&&(u.name=c.uri);const d=(o.samplers||{})[r.sampler]||{};return u.magFilter=$t[d.magFilter]||me,u.minFilter=$t[d.minFilter]||Es,u.wrapS=es[d.wrapS]||St,u.wrapT=es[d.wrapT]||St,i.associations.set(u,{textures:e}),u}).catch(function(){return null});return this.textureCache[a]=l,l}loadImageSource(e,s){const n=this,i=this.json,o=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(f=>f.clone());const r=i.images[e],c=self.URL||self.webkitURL;let a=r.uri||"",l=!1;if(r.bufferView!==void 0)a=n.getDependency("bufferView",r.bufferView).then(function(f){l=!0;const d=new Blob([f],{type:r.mimeType});return a=c.createObjectURL(d),a});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const u=Promise.resolve(a).then(function(f){return new Promise(function(d,h){let A=d;s.isImageBitmapLoader===!0&&(A=function(m){const p=new it(m);p.needsUpdate=!0,d(p)}),s.load(_e.resolveURL(f,o.path),A,void 0,h)})}).then(function(f){return l===!0&&c.revokeObjectURL(a),oe(f,r),f.userData.mimeType=r.mimeType||Zi(r.uri),f}).catch(function(f){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),f});return this.sourceCache[e]=u,u}assignTexture(e,s,n,i){const o=this;return this.getDependency("texture",n.index).then(function(r){if(!r)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(r=r.clone(),r.channel=n.texCoord),o.extensions[D.KHR_TEXTURE_TRANSFORM]){const c=n.extensions!==void 0?n.extensions[D.KHR_TEXTURE_TRANSFORM]:void 0;if(c){const a=o.associations.get(r);r=o.extensions[D.KHR_TEXTURE_TRANSFORM].extendTexture(r,c),o.associations.set(r,a)}}return i!==void 0&&(typeof i=="number"&&(i=i===Zt?Me:le),"colorSpace"in r?r.colorSpace=i:r.encoding=i===Me?Zt:Ci),e[s]=r,r})}assignFinalMaterial(e){const s=e.geometry;let n=e.material;const i=s.attributes.tangent===void 0,o=s.attributes.color!==void 0,r=s.attributes.normal===void 0;if(e.isPoints){const c="PointsMaterial:"+n.uuid;let a=this.cache.get(c);a||(a=new xs,Je.prototype.copy.call(a,n),a.color.copy(n.color),a.map=n.map,a.sizeAttenuation=!1,this.cache.add(c,a)),n=a}else if(e.isLine){const c="LineBasicMaterial:"+n.uuid;let a=this.cache.get(c);a||(a=new Tn,Je.prototype.copy.call(a,n),a.color.copy(n.color),a.map=n.map,this.cache.add(c,a)),n=a}if(i||o||r){let c="ClonedMaterial:"+n.uuid+":";i&&(c+="derivative-tangents:"),o&&(c+="vertex-colors:"),r&&(c+="flat-shading:");let a=this.cache.get(c);a||(a=n.clone(),o&&(a.vertexColors=!0),r&&(a.flatShading=!0),i&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(c,a),this.associations.set(a,this.associations.get(n))),n=a}e.material=n}getMaterialType(){return Ts}loadMaterial(e){const s=this,n=this.json,i=this.extensions,o=n.materials[e];let r;const c={},a=o.extensions||{},l=[];if(a[D.KHR_MATERIALS_UNLIT]){const f=i[D.KHR_MATERIALS_UNLIT];r=f.getMaterialType(),l.push(f.extendParams(c,o,s))}else{const f=o.pbrMetallicRoughness||{};if(c.color=new ie(1,1,1),c.opacity=1,Array.isArray(f.baseColorFactor)){const d=f.baseColorFactor;c.color.setRGB(d[0],d[1],d[2],le),c.opacity=d[3]}f.baseColorTexture!==void 0&&l.push(s.assignTexture(c,"map",f.baseColorTexture,Me)),c.metalness=f.metallicFactor!==void 0?f.metallicFactor:1,c.roughness=f.roughnessFactor!==void 0?f.roughnessFactor:1,f.metallicRoughnessTexture!==void 0&&(l.push(s.assignTexture(c,"metalnessMap",f.metallicRoughnessTexture)),l.push(s.assignTexture(c,"roughnessMap",f.metallicRoughnessTexture))),r=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,c)})))}o.doubleSided===!0&&(c.side=be);const u=o.alphaMode||At.OPAQUE;if(u===At.BLEND?(c.transparent=!0,c.depthWrite=!1):(c.transparent=!1,u===At.MASK&&(c.alphaTest=o.alphaCutoff!==void 0?o.alphaCutoff:.5)),o.normalTexture!==void 0&&r!==Le&&(l.push(s.assignTexture(c,"normalMap",o.normalTexture)),c.normalScale=new N(1,1),o.normalTexture.scale!==void 0)){const f=o.normalTexture.scale;c.normalScale.set(f,f)}if(o.occlusionTexture!==void 0&&r!==Le&&(l.push(s.assignTexture(c,"aoMap",o.occlusionTexture)),o.occlusionTexture.strength!==void 0&&(c.aoMapIntensity=o.occlusionTexture.strength)),o.emissiveFactor!==void 0&&r!==Le){const f=o.emissiveFactor;c.emissive=new ie().setRGB(f[0],f[1],f[2],le)}return o.emissiveTexture!==void 0&&r!==Le&&l.push(s.assignTexture(c,"emissiveMap",o.emissiveTexture,Me)),Promise.all(l).then(function(){const f=new r(c);return o.name&&(f.name=o.name),oe(f,o),s.associations.set(f,{materials:e}),o.extensions&&ve(i,f,o),f})}createUniqueName(e){const s=Sn.sanitizeNodeName(e||"");return s in this.nodeNamesUsed?s+"_"+ ++this.nodeNamesUsed[s]:(this.nodeNamesUsed[s]=0,s)}loadGeometries(e){const s=this,n=this.extensions,i=this.primitiveCache;function o(c){return n[D.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(c,s).then(function(a){return ts(a,c,s)})}const r=[];for(let c=0,a=e.length;c<a;c++){const l=e[c],u=Wi(l),f=i[u];if(f)r.push(f.promise);else{let d;l.extensions&&l.extensions[D.KHR_DRACO_MESH_COMPRESSION]?d=o(l):d=ts(new ke,l,s),i[u]={primitive:l,promise:d},r.push(d)}}return Promise.all(r)}loadMesh(e){const s=this,n=this.json,i=this.extensions,o=n.meshes[e],r=o.primitives,c=[];for(let a=0,l=r.length;a<l;a++){const u=r[a].material===void 0?ji(this.cache):this.getDependency("material",r[a].material);c.push(u)}return c.push(s.loadGeometries(r)),Promise.all(c).then(function(a){const l=a.slice(0,a.length-1),u=a[a.length-1],f=[];for(let h=0,A=u.length;h<A;h++){const m=u[h],p=r[h];let B;const v=l[h];if(p.mode===Z.TRIANGLES||p.mode===Z.TRIANGLE_STRIP||p.mode===Z.TRIANGLE_FAN||p.mode===void 0)B=o.isSkinnedMesh===!0?new yn(m,v):new Qe(m,v),B.isSkinnedMesh===!0&&B.normalizeSkinWeights(),p.mode===Z.TRIANGLE_STRIP?B.geometry=Wt(B.geometry,vs):p.mode===Z.TRIANGLE_FAN&&(B.geometry=Wt(B.geometry,Tt));else if(p.mode===Z.LINES)B=new Rn(m,v);else if(p.mode===Z.LINE_STRIP)B=new bn(m,v);else if(p.mode===Z.LINE_LOOP)B=new Fn(m,v);else if(p.mode===Z.POINTS)B=new Gt(m,v);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+p.mode);Object.keys(B.geometry.morphAttributes).length>0&&Yi(B,o),B.name=s.createUniqueName(o.name||"mesh_"+e),oe(B,o),p.extensions&&ve(i,B,p),s.assignFinalMaterial(B),f.push(B)}for(let h=0,A=f.length;h<A;h++)s.associations.set(f[h],{meshes:e,primitives:h});if(f.length===1)return o.extensions&&ve(i,f[0],o),f[0];const d=new Ne;o.extensions&&ve(i,d,o),s.associations.set(d,{meshes:e});for(let h=0,A=f.length;h<A;h++)d.add(f[h]);return d})}loadCamera(e){let s;const n=this.json.cameras[e],i=n[n.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?s=new Ss(pe.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):n.type==="orthographic"&&(s=new Dn(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(s.name=this.createUniqueName(n.name)),oe(s,n),Promise.resolve(s)}loadSkin(e){const s=this.json.skins[e],n=[];for(let i=0,o=s.joints.length;i<o;i++)n.push(this._loadNodeShallow(s.joints[i]));return s.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",s.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(i){const o=i.pop(),r=i,c=[],a=[];for(let l=0,u=r.length;l<u;l++){const f=r[l];if(f){c.push(f);const d=new Ie;o!==null&&d.fromArray(o.array,l*16),a.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',s.joints[l])}return new In(c,a)})}loadAnimation(e){const s=this.json,n=this,i=s.animations[e],o=i.name?i.name:"animation_"+e,r=[],c=[],a=[],l=[],u=[];for(let f=0,d=i.channels.length;f<d;f++){const h=i.channels[f],A=i.samplers[h.sampler],m=h.target,p=m.node,B=i.parameters!==void 0?i.parameters[A.input]:A.input,v=i.parameters!==void 0?i.parameters[A.output]:A.output;m.node!==void 0&&(r.push(this.getDependency("node",p)),c.push(this.getDependency("accessor",B)),a.push(this.getDependency("accessor",v)),l.push(A),u.push(m))}return Promise.all([Promise.all(r),Promise.all(c),Promise.all(a),Promise.all(l),Promise.all(u)]).then(function(f){const d=f[0],h=f[1],A=f[2],m=f[3],p=f[4],B=[];for(let v=0,C=d.length;v<C;v++){const M=d[v],E=h[v],S=A[v],R=m[v],T=p[v];if(M===void 0)continue;M.updateMatrix&&M.updateMatrix();const b=n._createAnimationTracks(M,E,S,R,T);if(b)for(let G=0;G<b.length;G++)B.push(b[G])}return new Gn(o,void 0,B)})}createNodeMesh(e){const s=this.json,n=this,i=s.nodes[e];return i.mesh===void 0?null:n.getDependency("mesh",i.mesh).then(function(o){const r=n._getNodeRef(n.meshCache,i.mesh,o);return i.weights!==void 0&&r.traverse(function(c){if(c.isMesh)for(let a=0,l=i.weights.length;a<l;a++)c.morphTargetInfluences[a]=i.weights[a]}),r})}loadNode(e){const s=this.json,n=this,i=s.nodes[e],o=n._loadNodeShallow(e),r=[],c=i.children||[];for(let l=0,u=c.length;l<u;l++)r.push(n.getDependency("node",c[l]));const a=i.skin===void 0?Promise.resolve(null):n.getDependency("skin",i.skin);return Promise.all([o,Promise.all(r),a]).then(function(l){const u=l[0],f=l[1],d=l[2];d!==null&&u.traverse(function(h){h.isSkinnedMesh&&h.bind(d,qi)});for(let h=0,A=f.length;h<A;h++)u.add(f[h]);return u})}_loadNodeShallow(e){const s=this.json,n=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const o=s.nodes[e],r=o.name?i.createUniqueName(o.name):"",c=[],a=i._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return a&&c.push(a),o.camera!==void 0&&c.push(i.getDependency("camera",o.camera).then(function(l){return i._getNodeRef(i.cameraCache,o.camera,l)})),i._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){c.push(l)}),this.nodeCache[e]=Promise.all(c).then(function(l){let u;if(o.isBone===!0?u=new wn:l.length>1?u=new Ne:l.length===1?u=l[0]:u=new Ms,u!==l[0])for(let f=0,d=l.length;f<d;f++)u.add(l[f]);if(o.name&&(u.userData.name=o.name,u.name=r),oe(u,o),o.extensions&&ve(n,u,o),o.matrix!==void 0){const f=new Ie;f.fromArray(o.matrix),u.applyMatrix4(f)}else o.translation!==void 0&&u.position.fromArray(o.translation),o.rotation!==void 0&&u.quaternion.fromArray(o.rotation),o.scale!==void 0&&u.scale.fromArray(o.scale);return i.associations.has(u)||i.associations.set(u,{}),i.associations.get(u).nodes=e,u}),this.nodeCache[e]}loadScene(e){const s=this.extensions,n=this.json.scenes[e],i=this,o=new Ne;n.name&&(o.name=i.createUniqueName(n.name)),oe(o,n),n.extensions&&ve(s,o,n);const r=n.nodes||[],c=[];for(let a=0,l=r.length;a<l;a++)c.push(i.getDependency("node",r[a]));return Promise.all(c).then(function(a){for(let u=0,f=a.length;u<f;u++)o.add(a[u]);const l=u=>{const f=new Map;for(const[d,h]of i.associations)(d instanceof Je||d instanceof it)&&f.set(d,h);return u.traverse(d=>{const h=i.associations.get(d);h!=null&&f.set(d,h)}),f};return i.associations=l(o),o})}_createAnimationTracks(e,s,n,i,o){const r=[],c=e.name?e.name:e.uuid,a=[];de[o.path]===de.weights?e.traverse(function(d){d.morphTargetInfluences&&a.push(d.name?d.name:d.uuid)}):a.push(c);let l;switch(de[o.path]){case de.weights:l=Jt;break;case de.rotation:l=Nt;break;case de.position:case de.scale:l=_t;break;default:switch(n.itemSize){case 1:l=Jt;break;case 2:case 3:default:l=_t;break}break}const u=i.interpolation!==void 0?Xi[i.interpolation]:ys,f=this._getArrayFromAccessor(n);for(let d=0,h=a.length;d<h;d++){const A=new l(a[d]+"."+de[o.path],s.array,f,u);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(A),r.push(A)}return r}_getArrayFromAccessor(e){let s=e.array;if(e.normalized){const n=Dt(s.constructor),i=new Float32Array(s.length);for(let o=0,r=s.length;o<r;o++)i[o]=s[o]*n;s=i}return s}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(n){const i=this instanceof Nt?Qi:Qs;return new i(this.times,this.values,this.getValueSize()/3,n)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function er(t,e,s){const n=e.attributes,i=new Nn;if(n.POSITION!==void 0){const c=s.json.accessors[n.POSITION],a=c.min,l=c.max;if(a!==void 0&&l!==void 0){if(i.set(new V(a[0],a[1],a[2]),new V(l[0],l[1],l[2])),c.normalized){const u=Dt(De[c.componentType]);i.min.multiplyScalar(u),i.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const o=e.targets;if(o!==void 0){const c=new V,a=new V;for(let l=0,u=o.length;l<u;l++){const f=o[l];if(f.POSITION!==void 0){const d=s.json.accessors[f.POSITION],h=d.min,A=d.max;if(h!==void 0&&A!==void 0){if(a.setX(Math.max(Math.abs(h[0]),Math.abs(A[0]))),a.setY(Math.max(Math.abs(h[1]),Math.abs(A[1]))),a.setZ(Math.max(Math.abs(h[2]),Math.abs(A[2]))),d.normalized){const m=Dt(De[d.componentType]);a.multiplyScalar(m)}c.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(c)}t.boundingBox=i;const r=new Fs;i.getCenter(r.center),r.radius=i.min.distanceTo(i.max)/2,t.boundingSphere=r}function ts(t,e,s){const n=e.attributes,i=[];function o(r,c){return s.getDependency("accessor",r).then(function(a){t.setAttribute(c,a)})}for(const r in n){const c=Ft[r]||r.toLowerCase();c in t.attributes||i.push(o(n[r],c))}if(e.indices!==void 0&&!t.index){const r=s.getDependency("accessor",e.indices).then(function(c){t.setIndex(c)});i.push(r)}return oe(t,e),er(t,e,s),Promise.all(i).then(function(){return e.targets!==void 0?Vi(t,e.targets,s):t})}const mt=new WeakMap;class tr extends Cs{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,s,n,i){const o=new nt(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,r=>{const c={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(r,c).then(s).catch(i)},n,i)}decodeDracoFile(e,s,n,i){const o={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(e,o).then(s)}decodeGeometry(e,s){for(const a in s.attributeTypes){const l=s.attributeTypes[a];l.BYTES_PER_ELEMENT!==void 0&&(s.attributeTypes[a]=l.name)}const n=JSON.stringify(s);if(mt.has(e)){const a=mt.get(e);if(a.key===n)return a.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let i;const o=this.workerNextTaskID++,r=e.byteLength,c=this._getWorker(o,r).then(a=>(i=a,new Promise((l,u)=>{i._callbacks[o]={resolve:l,reject:u},i.postMessage({type:"decode",id:o,taskConfig:s,buffer:e},[e])}))).then(a=>this._createGeometry(a.geometry));return c.catch(()=>!0).then(()=>{i&&o&&this._releaseTask(i,o)}),mt.set(e,{key:n,promise:c}),c}_createGeometry(e){const s=new ke;e.index&&s.setIndex(new ce(e.index.array,1));for(let n=0;n<e.attributes.length;n++){const i=e.attributes[n],o=i.name,r=i.array,c=i.itemSize;s.setAttribute(o,new ce(r,c))}return s}_loadLibrary(e,s){const n=new nt(this.manager);return n.setPath(this.decoderPath),n.setResponseType(s),n.setWithCredentials(this.withCredentials),new Promise((i,o)=>{n.load(e,i,void 0,o)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",s=[];return e?s.push(this._loadLibrary("draco_decoder.js","text")):(s.push(this._loadLibrary("draco_wasm_wrapper.js","text")),s.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(s).then(n=>{const i=n[0];e||(this.decoderConfig.wasmBinary=n[1]);const o=sr.toString(),r=["/* draco decoder */",i,"","/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([r]))}),this.decoderPending}_getWorker(e,s){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const i=new Worker(this.workerSourceURL);i._callbacks={},i._taskCosts={},i._taskLoad=0,i.postMessage({type:"init",decoderConfig:this.decoderConfig}),i.onmessage=function(o){const r=o.data;switch(r.type){case"decode":i._callbacks[r.id].resolve(r);break;case"error":i._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(i)}else this.workerPool.sort(function(i,o){return i._taskLoad>o._taskLoad?-1:1});const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=s,n._taskLoad+=s,n})}_releaseTask(e,s){e._taskLoad-=e._taskCosts[s],delete e._callbacks[s],delete e._taskCosts[s]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function sr(){let t,e;onmessage=function(r){const c=r.data;switch(c.type){case"init":t=c.decoderConfig,e=new Promise(function(u){t.onModuleLoaded=function(f){u({draco:f})},DracoDecoderModule(t)});break;case"decode":const a=c.buffer,l=c.taskConfig;e.then(u=>{const f=u.draco,d=new f.Decoder,h=new f.DecoderBuffer;h.Init(new Int8Array(a),a.byteLength);try{const A=s(f,d,h,l),m=A.attributes.map(p=>p.array.buffer);A.index&&m.push(A.index.array.buffer),self.postMessage({type:"decode",id:c.id,geometry:A},m)}catch(A){console.error(A),self.postMessage({type:"error",id:c.id,error:A.message})}finally{f.destroy(h),f.destroy(d)}});break}};function s(r,c,a,l){const u=l.attributeIDs,f=l.attributeTypes;let d,h;const A=c.GetEncodedGeometryType(a);if(A===r.TRIANGULAR_MESH)d=new r.Mesh,h=c.DecodeBufferToMesh(a,d);else if(A===r.POINT_CLOUD)d=new r.PointCloud,h=c.DecodeBufferToPointCloud(a,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!h.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+h.error_msg());const m={index:null,attributes:[]};for(const p in u){const B=self[f[p]];let v,C;if(l.useUniqueIDs)C=u[p],v=c.GetAttributeByUniqueId(d,C);else{if(C=c.GetAttributeId(d,r[u[p]]),C===-1)continue;v=c.GetAttribute(d,C)}m.attributes.push(i(r,c,d,p,B,v))}return A===r.TRIANGULAR_MESH&&(m.index=n(r,c,d)),r.destroy(d),m}function n(r,c,a){const u=a.num_faces()*3,f=u*4,d=r._malloc(f);c.GetTrianglesUInt32Array(a,f,d);const h=new Uint32Array(r.HEAPF32.buffer,d,u).slice();return r._free(d),{array:h,itemSize:1}}function i(r,c,a,l,u,f){const d=f.num_components(),A=a.num_points()*d,m=A*u.BYTES_PER_ELEMENT,p=o(r,u),B=r._malloc(m);c.GetAttributeDataArrayForAllPoints(a,f,p,m,B);const v=new u(r.HEAPF32.buffer,B,A).slice();return r._free(B),{name:l,array:v,itemSize:d}}function o(r,c){switch(c){case Float32Array:return r.DT_FLOAT32;case Int8Array:return r.DT_INT8;case Int16Array:return r.DT_INT16;case Int32Array:return r.DT_INT32;case Uint8Array:return r.DT_UINT8;case Uint16Array:return r.DT_UINT16;case Uint32Array:return r.DT_UINT32}}}let $e;const gt=()=>{if($e)return $e;const t="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",e="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",s=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),n=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let i=t;WebAssembly.validate(s)&&(i=e);let o;const r=WebAssembly.instantiate(c(i),{}).then(f=>{o=f.instance,o.exports.__wasm_call_ctors()});function c(f){const d=new Uint8Array(f.length);for(let A=0;A<f.length;++A){const m=f.charCodeAt(A);d[A]=m>96?m-71:m>64?m-65:m>47?m+4:m>46?63:62}let h=0;for(let A=0;A<f.length;++A)d[h++]=d[A]<60?n[d[A]]:(d[A]-60)*64+d[++A];return d.buffer.slice(0,h)}function a(f,d,h,A,m,p){const B=o.exports.sbrk,v=h+3&-4,C=B(v*A),M=B(m.length),E=new Uint8Array(o.exports.memory.buffer);E.set(m,M);const S=f(C,h,A,M,m.length);if(S===0&&p&&p(C,v,A),d.set(E.subarray(C,C+h*A)),B(C-B(0)),S!==0)throw new Error(`Malformed buffer data: ${S}`)}const l={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},u={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return $e={ready:r,supported:!0,decodeVertexBuffer(f,d,h,A,m){a(o.exports.meshopt_decodeVertexBuffer,f,d,h,A,o.exports[l[m]])},decodeIndexBuffer(f,d,h,A){a(o.exports.meshopt_decodeIndexBuffer,f,d,h,A)},decodeIndexSequence(f,d,h,A){a(o.exports.meshopt_decodeIndexSequence,f,d,h,A)},decodeGltfBuffer(f,d,h,A,m,p){a(o.exports[u[m]],f,d,h,A,o.exports[l[p]])}},$e},nr=()=>parseInt(Ke.replace(/\D+/g,"")),Xs=nr();let et=null,js="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function Vs(t,e,s){return n=>{s&&s(n),t&&(et||(et=new tr),et.setDecoderPath(typeof t=="string"?t:js),n.setDRACOLoader(et)),e&&n.setMeshoptDecoder(typeof gt=="function"?gt():gt)}}function Ve(t,e=!0,s=!0,n){return wt(Ot,t,Vs(e,s,n))}Ve.preload=(t,e=!0,s=!0,n)=>wt.preload(Ot,t,Vs(e,s,n));Ve.clear=t=>wt.clear(Ot,t);Ve.setDecoderPath=t=>{js=t};function Ys(t,e,s){const n=z(d=>d.size),i=z(d=>d.viewport),o=typeof t=="number"?t:n.width*i.dpr,r=n.height*i.dpr,c=(typeof t=="number"?s:t)||{},{samples:a=0,depth:l,...u}=c,f=g.useMemo(()=>{const d=new se(o,r,{minFilter:me,magFilter:me,type:Ds,...u});return l&&(d.depthTexture=new Is(o,r,Gs)),d.samples=a,d},[]);return g.useLayoutEffect(()=>{f.setSize(o,r),a&&(f.samples=a)},[a,f,o,r]),g.useEffect(()=>()=>f.dispose(),[]),f}const ir=t=>typeof t=="function",ss=g.forwardRef(({envMap:t,resolution:e=256,frames:s=1/0,children:n,makeDefault:i,...o},r)=>{const c=z(({set:p})=>p),a=z(({camera:p})=>p),l=z(({size:p})=>p),u=g.useRef(null),f=g.useRef(null),d=Ys(e);g.useLayoutEffect(()=>{o.manual||u.current.updateProjectionMatrix()},[l,o]),g.useLayoutEffect(()=>{u.current.updateProjectionMatrix()}),g.useLayoutEffect(()=>{if(i){const p=a;return c(()=>({camera:u.current})),()=>c(()=>({camera:p}))}},[u,i,c]);let h=0,A=null;const m=ir(n);return q(p=>{m&&(s===1/0||h<s)&&(f.current.visible=!1,p.gl.setRenderTarget(d),A=p.scene.background,t&&(p.scene.background=t),p.gl.render(p.scene,u.current),p.scene.background=A,p.gl.setRenderTarget(null),f.current.visible=!0,h++)}),g.createElement(g.Fragment,null,g.createElement("orthographicCamera",ge({left:l.width/-2,right:l.width/2,top:l.height/2,bottom:l.height/-2,ref:je([u,r])},o),!m&&n),g.createElement("group",{ref:f},m&&n(d.texture)))}),rr=t=>typeof t=="function",or=g.forwardRef(({envMap:t,resolution:e=256,frames:s=1/0,makeDefault:n,children:i,...o},r)=>{const c=z(({set:p})=>p),a=z(({camera:p})=>p),l=z(({size:p})=>p),u=g.useRef(null),f=g.useRef(null),d=Ys(e);g.useLayoutEffect(()=>{o.manual||(u.current.aspect=l.width/l.height)},[l,o]),g.useLayoutEffect(()=>{u.current.updateProjectionMatrix()});let h=0,A=null;const m=rr(i);return q(p=>{m&&(s===1/0||h<s)&&(f.current.visible=!1,p.gl.setRenderTarget(d),A=p.scene.background,t&&(p.scene.background=t),p.gl.render(p.scene,u.current),p.scene.background=A,p.gl.setRenderTarget(null),f.current.visible=!0,h++)}),g.useLayoutEffect(()=>{if(n){const p=a;return c(()=>({camera:u.current})),()=>c(()=>({camera:p}))}},[u,n,c]),g.createElement(g.Fragment,null,g.createElement("perspectiveCamera",ge({ref:je([u,r])},o),!m&&i),g.createElement("group",{ref:f},m&&i(d.texture)))});function ar({defaultScene:t,defaultCamera:e,renderPriority:s=1}){const{gl:n,scene:i,camera:o}=z();let r;return q(()=>{r=n.autoClear,s===1&&(n.autoClear=!0,n.render(t,e)),n.autoClear=!1,n.clearDepth(),n.render(i,o),n.autoClear=r},s),g.createElement("group",{onPointerOver:()=>null})}function ns({children:t,renderPriority:e=1}){const{scene:s,camera:n}=z(),[i]=g.useState(()=>new yt);return g.createElement(g.Fragment,null,Kn(g.createElement(g.Fragment,null,t,g.createElement(ar,{defaultScene:s,defaultCamera:n,renderPriority:e})),i,{events:{priority:e+1}}))}const Bt=Xs>=154?"opaque_fragment":"output_fragment";class cr extends xs{constructor(e){super(e),this.onBeforeCompile=(s,n)=>{const{isWebGL2:i}=n.capabilities;s.fragmentShader=s.fragmentShader.replace(`#include <${Bt}>`,`
        ${i?`#include <${Bt}>`:`#extension GL_OES_standard_derivatives : enable
#include <${Bt}>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <${Xs>=154?"colorspace_fragment":"encodings_fragment"}>
      `)}}}const lr=g.forwardRef((t,e)=>{const[s]=g.useState(()=>new cr(null));return g.createElement("primitive",ge({},t,{object:s,ref:e,attach:"material"}))}),is=new Ie,vt=new kn,rs=new Fs,ur=new V;class fr extends Ne{constructor(){super(),this.size=0,this.color=new ie("white"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return(e=this.instance.current)==null?void 0:e.geometry}raycast(e,s){var n,i;const o=this.instance.current;if(!o||!o.geometry)return;const r=o.userData.instances.indexOf(this.instanceKey);if(r===-1||r>o.geometry.drawRange.count)return;const c=(n=(i=e.params.Points)==null?void 0:i.threshold)!==null&&n!==void 0?n:1;if(rs.set(this.getWorldPosition(ur),c),e.ray.intersectsSphere(rs)===!1)return;is.copy(o.matrixWorld).invert(),vt.copy(e.ray).applyMatrix4(is);const a=c/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=vt.distanceSqToPoint(this.position);if(u<l){const f=new V;vt.closestPointToPoint(this.position,f),f.applyMatrix4(this.matrixWorld);const d=e.ray.origin.distanceTo(f);if(d<e.near||d>e.far)return;s.push({distance:d,distanceToRay:Math.sqrt(u),point:f,index:r,face:null,object:this})}}}let Ce,He;const Ws=g.createContext(null),os=new Ie,as=new V,dr=g.forwardRef(({children:t,range:e,limit:s=1e3,...n},i)=>{const o=g.useRef(null),[r,c]=g.useState([]),[[a,l,u]]=g.useState(()=>[new Float32Array(s*3),Float32Array.from({length:s*3},()=>1),Float32Array.from({length:s},()=>1)]);g.useEffect(()=>{o.current.geometry.attributes.position.needsUpdate=!0}),q(()=>{for(o.current.updateMatrix(),o.current.updateMatrixWorld(),os.copy(o.current.matrixWorld).invert(),o.current.geometry.drawRange.count=Math.min(s,e!==void 0?e:s,r.length),Ce=0;Ce<r.length;Ce++)He=r[Ce].current,He.getWorldPosition(as).applyMatrix4(os),as.toArray(a,Ce*3),o.current.geometry.attributes.position.needsUpdate=!0,He.matrixWorldNeedsUpdate=!0,He.color.toArray(l,Ce*3),o.current.geometry.attributes.color.needsUpdate=!0,u.set([He.size],Ce),o.current.geometry.attributes.size.needsUpdate=!0});const f=g.useMemo(()=>({getParent:()=>o,subscribe:d=>(c(h=>[...h,d]),()=>c(h=>h.filter(A=>A.current!==d.current)))}),[]);return g.createElement("points",ge({userData:{instances:r},matrixAutoUpdate:!1,ref:je([i,o]),raycast:()=>null},n),g.createElement("bufferGeometry",null,g.createElement("bufferAttribute",{attach:"attributes-position",count:a.length/3,array:a,itemSize:3,usage:Fe}),g.createElement("bufferAttribute",{attach:"attributes-color",count:l.length/3,array:l,itemSize:3,usage:Fe}),g.createElement("bufferAttribute",{attach:"attributes-size",count:u.length,array:u,itemSize:1,usage:Fe})),g.createElement(Ws.Provider,{value:f},t))}),hr=g.forwardRef(({children:t,...e},s)=>{g.useMemo(()=>ws({PositionPoint:fr}),[]);const n=g.useRef(),{subscribe:i,getParent:o}=g.useContext(Ws);return g.useLayoutEffect(()=>i(n),[]),g.createElement("positionPoint",ge({instance:o(),instanceKey:n,ref:je([s,n])},e),t)}),Ar=g.forwardRef(({children:t,positions:e,colors:s,sizes:n,stride:i=3,...o},r)=>{const c=g.useRef(null);return q(()=>{const a=c.current.geometry.attributes;a.position.needsUpdate=!0,s&&(a.color.needsUpdate=!0),n&&(a.size.needsUpdate=!0)}),g.createElement("points",ge({ref:je([r,c])},o),g.createElement("bufferGeometry",null,g.createElement("bufferAttribute",{attach:"attributes-position",count:e.length/i,array:e,itemSize:i,usage:Fe}),s&&g.createElement("bufferAttribute",{attach:"attributes-color",count:s.length/i,array:s,itemSize:3,usage:Fe}),n&&g.createElement("bufferAttribute",{attach:"attributes-size",count:n.length/i,array:n,itemSize:1,usage:Fe})),t)}),cs=g.forwardRef((t,e)=>t.positions instanceof Float32Array?g.createElement(Ar,ge({},t,{ref:e})):g.createElement(dr,ge({},t,{ref:e})));function pr({pixelated:t}){const e=z(r=>r.gl),s=z(r=>r.internal.active),n=z(r=>r.performance.current),i=z(r=>r.viewport.initialDpr),o=z(r=>r.setDpr);return g.useEffect(()=>{const r=e.domElement;return()=>{s&&o(i),t&&r&&(r.style.imageRendering="auto")}},[]),g.useEffect(()=>{o(n*i),t&&e.domElement&&(e.domElement.style.imageRendering=n===1?"auto":"pixelated")},[n]),null}const mr=[{point:1/0,blobRadius:5.5,blobPointSize:6,blobPointDensity:180,blobMoveY:7.5,blobMoveX:6,cropFaseZ:3,logoScale:5,logoEnableMouseReaction:!0,cameraZ:15,universeDensity:14e3,universeInitialRadius:2.5,universeMinPointSize:1,universeMaxPointSize:6,universeMaxPointsPerRenderFrame:20,starsFlowSpeed:.01,starsCloseDensity:600,starsFarDensity:300,starsEnbaleMouseReaction:!0},{point:1025,blobRadius:2.75,blobPointSize:4,blobPointDensity:90,blobMoveY:7,blobMoveX:0,cropFaseZ:2.75,logoScale:2.5,logoEnableMouseReaction:!1,cameraZ:25,universeDensity:5e3,universeInitialRadius:1.5,universeMinPointSize:.1,universeMaxPointSize:4,universeMaxPointsPerRenderFrame:10,starsFlowSpeed:.01,starsCloseDensity:600,starsFarDensity:300,starsEnbaleMouseReaction:!1}],we=t=>{let e={};return mr.sort((s,n)=>s.point+n.point).forEach(s=>{t<=s.point&&(e=s)}),e},at=()=>g.useMemo(()=>window.innerHeight*.07,[]),gr=`
//	Classic Perlin 3D Noise 
//	by Stefan Gustavson
//
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

float perlin4d(vec4 P){
  vec4 Pi0 = floor(P); // Integer part for indexing
  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
  Pi0 = mod(Pi0, 289.0);
  Pi1 = mod(Pi1, 289.0);
  vec4 Pf0 = fract(P); // Fractional part for interpolation
  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = vec4(Pi0.zzzz);
  vec4 iz1 = vec4(Pi1.zzzz);
  vec4 iw0 = vec4(Pi0.wwww);
  vec4 iw1 = vec4(Pi1.wwww);

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);
  vec4 ixy00 = permute(ixy0 + iw0);
  vec4 ixy01 = permute(ixy0 + iw1);
  vec4 ixy10 = permute(ixy1 + iw0);
  vec4 ixy11 = permute(ixy1 + iw1);

  vec4 gx00 = ixy00 / 7.0;
  vec4 gy00 = floor(gx00) / 7.0;
  vec4 gz00 = floor(gy00) / 6.0;
  gx00 = fract(gx00) - 0.5;
  gy00 = fract(gy00) - 0.5;
  gz00 = fract(gz00) - 0.5;
  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  vec4 sw00 = step(gw00, vec4(0.0));
  gx00 -= sw00 * (step(0.0, gx00) - 0.5);
  gy00 -= sw00 * (step(0.0, gy00) - 0.5);

  vec4 gx01 = ixy01 / 7.0;
  vec4 gy01 = floor(gx01) / 7.0;
  vec4 gz01 = floor(gy01) / 6.0;
  gx01 = fract(gx01) - 0.5;
  gy01 = fract(gy01) - 0.5;
  gz01 = fract(gz01) - 0.5;
  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  vec4 sw01 = step(gw01, vec4(0.0));
  gx01 -= sw01 * (step(0.0, gx01) - 0.5);
  gy01 -= sw01 * (step(0.0, gy01) - 0.5);

  vec4 gx10 = ixy10 / 7.0;
  vec4 gy10 = floor(gx10) / 7.0;
  vec4 gz10 = floor(gy10) / 6.0;
  gx10 = fract(gx10) - 0.5;
  gy10 = fract(gy10) - 0.5;
  gz10 = fract(gz10) - 0.5;
  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  vec4 sw10 = step(gw10, vec4(0.0));
  gx10 -= sw10 * (step(0.0, gx10) - 0.5);
  gy10 -= sw10 * (step(0.0, gy10) - 0.5);

  vec4 gx11 = ixy11 / 7.0;
  vec4 gy11 = floor(gx11) / 7.0;
  vec4 gz11 = floor(gy11) / 6.0;
  gx11 = fract(gx11) - 0.5;
  gy11 = fract(gy11) - 0.5;
  gz11 = fract(gz11) - 0.5;
  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  vec4 sw11 = step(gw11, vec4(0.0));
  gx11 -= sw11 * (step(0.0, gx11) - 0.5);
  gy11 -= sw11 * (step(0.0, gy11) - 0.5);

  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);

  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  g0000 *= norm00.x;
  g0100 *= norm00.y;
  g1000 *= norm00.z;
  g1100 *= norm00.w;

  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  g0001 *= norm01.x;
  g0101 *= norm01.y;
  g1001 *= norm01.z;
  g1101 *= norm01.w;

  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  g0010 *= norm10.x;
  g0110 *= norm10.y;
  g1010 *= norm10.z;
  g1110 *= norm10.w;

  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
  g0011 *= norm11.x;
  g0111 *= norm11.y;
  g1011 *= norm11.z;
  g1111 *= norm11.w;

  float n0000 = dot(g0000, Pf0);
  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
  float n1111 = dot(g1111, Pf1);

  vec4 fade_xyzw = fade(Pf0);
  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return 2.2 * n_xyzw;
}


// #pragma glslify: export(perlin4d)
`,Br=({material:t})=>{t.roughness=.4,t.metalness=.4,t.transparent=!0,t.depthTest=!0,t.depthWrite=!0;const e={value:null};return t.onBeforeCompile=n=>{n.uniforms.iTime={value:0},n.uniforms.iMouse={value:{x:0,y:0}},n.uniforms.iVelocity={value:0},n.uniforms.resolution={value:{x:window.innerWidth,y:window.innerHeight}},n.uniforms.baseColor={value:{r:.04,g:.25,b:.16}},n.uniforms.blobOut={value:0},n.uniforms.cropFaseZ={value:6},n.uniforms.uPixelRatio={value:Math.min(window.devicePixelRatio,2)},n.uniforms.blobNextSection={value:0},n.uniforms.blobSectionFour={value:0},n.vertexShader=`
            uniform float iTime;
            uniform vec2 iMouse;
            varying float vPerlingStrength;
            varying vec3 vUv2;
            varying vec2 vUv;
            uniform float iVelocity;
            attribute float size;
            varying vec3 vPosition;
            uniform float blobOut;
            uniform float uPixelRatio;

            attribute float random1;
            attribute float random2;
            attribute float random3;

            ${gr}

            float rand2(vec2 co) {
                return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
            }

            float backIn(float t) {
                const float s = 1.70158;
                return t * t * ((s + 1.0) * t - s);
            }

            vec4 getLiquedPosition() {
                vec3 pos = position;

                float uDisplacementFrequency = .6;
                float uDisplacementStrength = .3;

                float t = iTime;
                float perlingStrength = perlin4d(vec4(position * uDisplacementFrequency, t)) * uDisplacementStrength;
                pos += perlingStrength;

                return vec4(pos, perlingStrength);
            }

            vec3 getBlowPosition(float blobOut) {
                float angle = rand2(position.xz+.5);
                float radius = 10.0;
                float radians = angle * 6.28319; // 2 * PI
            
                float xOffset = cos(radians) * radius * random1;
                float yOffset = sin(radians) * radius * random2;
            
                vec3 blow = vec3(position.x + xOffset, position.y + yOffset, position.z);
                vec3 center = vec3(0.0, 0.0, -10.0);
            
                return mix(blow, center, blobOut);
            }

            

        `+n.vertexShader.replace("void main() {",`
            void main() {
                vec4 liquedPos = getLiquedPosition();
                vec3 blowPosition = getBlowPosition(blobOut);
                vec3 newPosition = mix(liquedPos.xyz, blowPosition, blobOut);

                vUv = uv;
                vNormal = normal;
                vPerlingStrength = liquedPos.w;
                vPosition = newPosition;
        `),n.vertexShader=n.vertexShader.replace("#include <fog_vertex>",`
            #include <fog_vertex>
            gl_PointSize = size * uPixelRatio * 0.5;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        `),n.fragmentShader=`
            varying float vPerlingStrength;
            varying vec2 vUv;
            uniform float iTime;
            uniform vec2 resolution;
            varying vec3 vPosition;

            uniform vec3 baseColor;
            uniform float blobOut;
            uniform float blobNextSection;
            uniform float blobSectionFour;

            uniform float cropFaseZ; //Used for mobile to make blob less bright on the front side


        `+n.fragmentShader.replace("void main() {",`
            void main() {
        `),n.fragmentShader=n.fragmentShader.replace("#include <dithering_fragment>",`
            #include <dithering_fragment>

            // Make Points Rounded
            vec2 pointUV = gl_PointCoord * 2.0 - 1.0;
            float distance = length(pointUV);
            float threshold = 0.8;
            if (distance >= threshold) {
                discard;
            }

            float perling = vPerlingStrength;
            // perling += .1;
            // perling = clamp(.5, 1., perling);


            // Fade Points to Center
            float transparency = smoothstep(-15., 2., vPosition.z) * (1. - smoothstep(0., cropFaseZ, vPosition.z));
            // transparency *= step(-2., vPosition.z);

            // Add Another Transparency not on the first section
            float transparencySectionThree = (1. - smoothstep(0., 4., vPosition.z));
            float transparencySectionFour = smoothstep(-10., 1., vPosition.z) * (1. - smoothstep(0., 1., vPosition.z));
            
            transparency = mix(transparency, transparencySectionThree, blobNextSection);
            transparency = mix(transparency, transparencySectionFour, blobSectionFour);
            

            // Clamp Additive Flame Colors based on Z coordinate (Distance)
            float clampShiftZ = (smoothstep(-5., 2., vPosition.z) - smoothstep(0., 4., vPosition.z));
            float clampShiftSectionThree = (smoothstep(-6., 6., vPosition.z) - smoothstep(0., 4., vPosition.z));
            clampShiftZ = mix(clampShiftZ, clampShiftSectionThree, blobNextSection);

            clampShiftZ = mix(clampShiftZ, 0., blobSectionFour);


            float clampShiftY = min((smoothstep(-5., 2., vPosition.y) - smoothstep(0., 4., vPosition.y)) + .5, 2.5);

            // float shiftColor = (smoothstep(-2., 0., vPosition.z) - smoothstep(0., 8., vPosition.z)) * (perling + .9);

            // Change Color Based on Perling
            float shiftColor = smoothstep(-2., 5., perling * 20.);
            // float shiftColorScreenTwo = smoothstep(-10., 2., perling * 10.);
            // shiftColor = mix(shiftColor, shiftColorScreenTwo, blobNextSection);


            float shiftCovered = (perling + .1);

            // White Color
            vec3 whiteColor = baseColor + (shiftColor+shiftCovered);
            // Green Color
            vec3 greenColor = vec3(.0, .0+shiftColor*.8, 0.);

            vec3 additiveColor = (whiteColor+greenColor) * clampShiftZ * clampShiftY;

            // White Balls
            // vec3 whiteBallsColor = vec3(.15) * perling * 8.;
            // float clampBalls = (smoothstep(-3. - 1., -3. + 1., vPosition.z));
            // vec3 additiveWhiteBalls = whiteBallsColor * clampBalls;

            vec3 whiteBallsColor = vec3(.2, .4, .3) * max(0., perling * 5. + 1.5);
            float clampBalls = (smoothstep(-3. - 2., -3. + 0., vPosition.z));
            vec3 additiveWhiteBalls = whiteBallsColor * clampBalls/2.;
            additiveWhiteBalls = mix(vec3(0.), additiveWhiteBalls, blobNextSection);

            vec3 color = mix(baseColor + additiveColor + additiveWhiteBalls, baseColor, blobOut);
            float alpha = max(mix(transparency, -.1, blobOut), 0.);

            gl_FragColor = vec4(color, alpha);
        `),e.value=n},{instance:t,render:n=>{e.value&&(e.value.uniforms.iTime.value=n)},shader:e}};function Ue(t,e,s){return(1-s)*t+s*e}function vr(t,e){return t+Math.random()*(e-t)}function Ct(t){return t*(.5-Math.random())}const Cr=()=>g.useMemo(()=>{const t=Br({material:new $}),e=new ke,s=we(window.innerWidth),n=[],i=[],o=[],r=[],c=[],a=s.blobPointDensity,l=s.blobPointDensity,u=s.blobRadius,f=s.blobPointSize;for(let h=0;h<a;h++){const A=2*Math.PI/a*h;for(let m=0;m<l;m++){const p=Math.PI/(l-1)*m,B=u*Math.sin(p)*Math.cos(A),v=u*Math.sin(p)*Math.sin(A),C=u*Math.cos(p),M=v*Math.cos(Math.PI/2)-C*Math.sin(Math.PI/2),E=v*Math.sin(Math.PI/2)+C*Math.cos(Math.PI/2);n.push(B,M,E),i.push(f),o.push(Ct(2)),r.push(Ct(2)),c.push(Ct(2))}}return e.setAttribute("position",new ae(n,3)),e.setAttribute("size",new ae(i,1)),e.setAttribute("random1",new ae(o,1)),e.setAttribute("random2",new ae(r,1)),e.setAttribute("random3",new ae(c,1)),{mesh:new Gt(e,t.instance),render:t.render,shader:t.shader}},[]),Mr=()=>{const t=g.useRef(null),e=g.useRef(0),s=g.useRef(new V),n=Cr(),i=Xe(),o=g.useMemo(()=>we(window.innerWidth),[]),r=g.useMemo(()=>window.innerWidth<=1024,[]),{blobMoveY:c,blobMoveX:a,cropFaseZ:l}=o,u=at(),f=g.useMemo(()=>new V(u,u,u),[u]);g.useEffect(()=>{var p,B;(B=(p=n.shader.value)==null?void 0:p.uniforms)!=null&&B.cropFaseZ&&(n.shader.value.uniforms.cropFaseZ.value=l)},[l,n.shader.value]);const d=g.useCallback((p,B)=>{p&&(p.blobOut&&(p.blobOut.value=B.blobOut),p.blobNextSection&&(p.blobNextSection.value=B.blobNextSection),p.blobSectionFour&&(p.blobSectionFour.value=B.blobSectionFour))},[]),h=g.useCallback((p,B,v,C,M,E)=>{const S=v?B.blobMobilePosY:0;s.current.set(C*B.blobPosX*E,M*B.blobPosY*E+M*E*S,p.position.z),p.position.copy(s.current)},[]),A=g.useCallback((p,B)=>{const v=B<.9;p.visible!==v&&(p.visible=v)},[]);q(({clock:p})=>{const B=p.getElapsedTime(),v=t.current,C=n.shader.value;if(!(B-e.current<1/60)){if(e.current=B,n.render(B),C!=null&&C.uniforms){const M=i.scrollData.get();d(C.uniforms,M)}if(v){const M=i.scrollData.get();h(v,M,r,a,c,u),A(v,M.blobOut)}}});const m=g.useCallback(p=>{p.scale.equals(f)||p.scale.copy(f)},[f]);return g.useEffect(()=>{t.current&&m(t.current)},[u,m]),y.jsx("primitive",{ref:t,object:n.mesh,scale:f})};/**
 * postprocessing v6.35.4 build Fri Apr 26 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rschen
 * @license Zlib
 */var Mt=1/1e3,Er=1e3,xr=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(t){typeof document<"u"&&document.hidden!==void 0&&(t?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=t)}get delta(){return this._delta*Mt}get fixedDelta(){return this._fixedDelta*Mt}set fixedDelta(t){this._fixedDelta=t*Er}get elapsed(){return this._elapsed*Mt}update(t){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(t!==void 0?t:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(t){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},Tr=new Yn,he=null;function Sr(){if(he===null){const t=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),e=new Float32Array([0,0,2,0,0,2]);he=new ke,he.setAttribute!==void 0?(he.setAttribute("position",new ce(t,3)),he.setAttribute("uv",new ce(e,2))):(he.addAttribute("position",new ce(t,3)),he.addAttribute("uv",new ce(e,2)))}return he}var Y=class Zs{constructor(e="Pass",s=new yt,n=Tr){this.name=e,this.renderer=null,this.scene=s,this.camera=n,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){const s=this.fullscreenMaterial;s!==null&&(s.needsUpdate=!0),this.rtt=!e}}set mainScene(e){}set mainCamera(e){}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(e){let s=this.screen;s!==null?s.material=e:(s=new Qe(Sr(),e),s.frustumCulled=!1,this.scene===null&&(this.scene=new yt),this.scene.add(s),this.screen=s)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,s=Ge){}render(e,s,n,i,o){throw new Error("Render method not implemented!")}setSize(e,s){}initialize(e,s,n){}dispose(){for(const e of Object.keys(this)){const s=this[e];(s instanceof se||s instanceof Je||s instanceof it||s instanceof Zs)&&this[e].dispose()}}},yr=class extends Y{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(t,e,s,n,i){const o=t.state.buffers.stencil;o.setLocked(!1),o.setTest(!1)}},Rr=Number(Ke.replace(/\D+/g,""));function Ye(t){return Rr<154?t.replace("colorspace_fragment","encodings_fragment"):t}var br=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,qs="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",$s=class extends ee{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new w(null),opacity:new w(1)},blending:Te,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:br,vertexShader:qs}),this.fragmentShader=Ye(this.fragmentShader)}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setInputBuffer(t){this.uniforms.inputBuffer.value=t}getOpacity(t){return this.uniforms.opacity.value}setOpacity(t){this.uniforms.opacity.value=t}},Fr=class extends Y{constructor(t,e=!0){super("CopyPass"),this.fullscreenMaterial=new $s,this.needsSwap=!1,this.renderTarget=t,t===void 0&&(this.renderTarget=new se(1,1,{minFilter:me,magFilter:me,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=e}get resize(){return this.autoResize}set resize(t){this.autoResize=t}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(t){this.autoResize=t}render(t,e,s,n,i){this.fullscreenMaterial.inputBuffer=e.texture,t.setRenderTarget(this.renderToScreen?null:this.renderTarget),t.render(this.scene,this.camera)}setSize(t,e){this.autoResize&&this.renderTarget.setSize(t,e)}initialize(t,e,s){s!==void 0&&(this.renderTarget.texture.type=s,s!==xe?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":t!==null&&t.outputColorSpace===k&&(this.renderTarget.texture.colorSpace=k))}},ls=new ie,en=class extends Y{constructor(t=!0,e=!0,s=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=t,this.depth=e,this.stencil=s,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(t,e,s){this.color=t,this.depth=e,this.stencil=s}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(t){this.overrideClearColor=t}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(t){this.overrideClearAlpha=t}render(t,e,s,n,i){const o=this.overrideClearColor,r=this.overrideClearAlpha,c=t.getClearAlpha(),a=o!==null,l=r>=0;a?(t.getClearColor(ls),t.setClearColor(o,l?r:c)):l&&t.setClearAlpha(r),t.setRenderTarget(this.renderToScreen?null:e),t.clear(this.color,this.depth,this.stencil),a?t.setClearColor(ls,c):l&&t.setClearAlpha(c)}},Dr=class extends Y{constructor(t,e){super("MaskPass",t,e),this.needsSwap=!1,this.clearPass=new en(!1,!1,!0),this.inverse=!1}set mainScene(t){this.scene=t}set mainCamera(t){this.camera=t}get inverted(){return this.inverse}set inverted(t){this.inverse=t}get clear(){return this.clearPass.enabled}set clear(t){this.clearPass.enabled=t}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(t){this.inverted=t}render(t,e,s,n,i){const o=t.getContext(),r=t.state.buffers,c=this.scene,a=this.camera,l=this.clearPass,u=this.inverted?0:1,f=1-u;r.color.setMask(!1),r.depth.setMask(!1),r.color.setLocked(!0),r.depth.setLocked(!0),r.stencil.setTest(!0),r.stencil.setOp(o.REPLACE,o.REPLACE,o.REPLACE),r.stencil.setFunc(o.ALWAYS,u,4294967295),r.stencil.setClear(f),r.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?l.render(t,null):(l.render(t,e),l.render(t,s))),this.renderToScreen?(t.setRenderTarget(null),t.render(c,a)):(t.setRenderTarget(e),t.render(c,a),t.setRenderTarget(s),t.render(c,a)),r.color.setLocked(!1),r.depth.setLocked(!1),r.stencil.setLocked(!1),r.stencil.setFunc(o.EQUAL,1,4294967295),r.stencil.setOp(o.KEEP,o.KEEP,o.KEEP),r.stencil.setLocked(!0)}},Ir=class{constructor(e=null,{depthBuffer:s=!0,stencilBuffer:n=!1,multisampling:i=0,frameBufferType:o}={}){this.renderer=null,this.inputBuffer=this.createBuffer(s,n,o,i),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new Fr,this.depthTexture=null,this.passes=[],this.timer=new xr,this.autoRenderToScreen=!0,this.setRenderer(e)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(e){const s=this.inputBuffer,n=this.multisampling;n>0&&e>0?(this.inputBuffer.samples=e,this.outputBuffer.samples=e,this.inputBuffer.dispose(),this.outputBuffer.dispose()):n!==e&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(s.depthBuffer,s.stencilBuffer,s.texture.type,e),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(e){if(this.renderer=e,e!==null){const s=e.getSize(new N),n=e.getContext().getContextAttributes().alpha,i=this.inputBuffer.texture.type;i===xe&&e.outputColorSpace===k&&(this.inputBuffer.texture.colorSpace=k,this.outputBuffer.texture.colorSpace=k,this.inputBuffer.dispose(),this.outputBuffer.dispose()),e.autoClear=!1,this.setSize(s.width,s.height);for(const o of this.passes)o.initialize(e,n,i)}}replaceRenderer(e,s=!0){const n=this.renderer,i=n.domElement.parentNode;return this.setRenderer(e),s&&i!==null&&(i.removeChild(n.domElement),i.appendChild(e.domElement)),n}createDepthTexture(){const e=this.depthTexture=new Is;return this.inputBuffer.depthTexture=e,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(e.format=Qn,e.type=Xn):e.type=jn,e}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const e of this.passes)e.setDepthTexture(null)}}createBuffer(e,s,n,i){const o=this.renderer,r=o===null?new N:o.getDrawingBufferSize(new N),c={minFilter:me,magFilter:me,stencilBuffer:s,depthBuffer:e,type:n},a=new se(r.width,r.height,c);return i>0&&(a.ignoreDepthForMultisampleCopy=!1,a.samples=i),n===xe&&o!==null&&o.outputColorSpace===k&&(a.texture.colorSpace=k),a.texture.name="EffectComposer.Buffer",a.texture.generateMipmaps=!1,a}setMainScene(e){for(const s of this.passes)s.mainScene=e}setMainCamera(e){for(const s of this.passes)s.mainCamera=e}addPass(e,s){const n=this.passes,i=this.renderer,o=i.getDrawingBufferSize(new N),r=i.getContext().getContextAttributes().alpha,c=this.inputBuffer.texture.type;if(e.setRenderer(i),e.setSize(o.width,o.height),e.initialize(i,r,c),this.autoRenderToScreen&&(n.length>0&&(n[n.length-1].renderToScreen=!1),e.renderToScreen&&(this.autoRenderToScreen=!1)),s!==void 0?n.splice(s,0,e):n.push(e),this.autoRenderToScreen&&(n[n.length-1].renderToScreen=!0),e.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const a=this.createDepthTexture();for(e of n)e.setDepthTexture(a)}else e.setDepthTexture(this.depthTexture)}removePass(e){const s=this.passes,n=s.indexOf(e);if(n!==-1&&s.splice(n,1).length>0){if(this.depthTexture!==null){const r=(a,l)=>a||l.needsDepthTexture;s.reduce(r,!1)||(e.getDepthTexture()===this.depthTexture&&e.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&n===s.length&&(e.renderToScreen=!1,s.length>0&&(s[s.length-1].renderToScreen=!0))}}removeAllPasses(){const e=this.passes;this.deleteDepthTexture(),e.length>0&&(this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!1),this.passes=[])}render(e){const s=this.renderer,n=this.copyPass;let i=this.inputBuffer,o=this.outputBuffer,r=!1,c,a,l;e===void 0&&(this.timer.update(),e=this.timer.getDelta());for(const u of this.passes)u.enabled&&(u.render(s,i,o,e,r),u.needsSwap&&(r&&(n.renderToScreen=u.renderToScreen,c=s.getContext(),a=s.state.buffers.stencil,a.setFunc(c.NOTEQUAL,1,4294967295),n.render(s,i,o,e,r),a.setFunc(c.EQUAL,1,4294967295)),l=i,i=o,o=l),u instanceof Dr?r=!0:u instanceof yr&&(r=!1))}setSize(e,s,n){const i=this.renderer,o=i.getSize(new N);(e===void 0||s===void 0)&&(e=o.width,s=o.height),(o.width!==e||o.height!==s)&&i.setSize(e,s,n);const r=i.getDrawingBufferSize(new N);this.inputBuffer.setSize(r.width,r.height),this.outputBuffer.setSize(r.width,r.height);for(const c of this.passes)c.setSize(r.width,r.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const e of this.passes)e.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose()}},ue={NONE:0,DEPTH:1,CONVOLUTION:2},I={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},Gr=class{constructor(){this.shaderParts=new Map([[I.FRAGMENT_HEAD,null],[I.FRAGMENT_MAIN_UV,null],[I.FRAGMENT_MAIN_IMAGE,null],[I.VERTEX_HEAD,null],[I.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=ue.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=Ps}},Et=!1,us=class{constructor(t=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(t),this.meshCount=0,this.replaceMaterial=e=>{if(e.isMesh){let s;if(e.material.flatShading)switch(e.material.side){case be:s=this.materialsFlatShadedDoubleSide;break;case qe:s=this.materialsFlatShadedBackSide;break;default:s=this.materialsFlatShaded;break}else switch(e.material.side){case be:s=this.materialsDoubleSide;break;case qe:s=this.materialsBackSide;break;default:s=this.materials;break}this.originalMaterials.set(e,e.material),e.isSkinnedMesh?e.material=s[2]:e.isInstancedMesh?e.material=s[1]:e.material=s[0],++this.meshCount}}}cloneMaterial(t){if(!(t instanceof ee))return t.clone();const e=t.uniforms,s=new Map;for(const i in e){const o=e[i].value;o.isRenderTargetTexture&&(e[i].value=null,s.set(i,o))}const n=t.clone();for(const i of s)e[i[0]].value=i[1],n.uniforms[i[0]].value=i[1];return n}setMaterial(t){if(this.disposeMaterials(),this.material=t,t!==null){const e=this.materials=[this.cloneMaterial(t),this.cloneMaterial(t),this.cloneMaterial(t)];for(const s of e)s.uniforms=Object.assign({},t.uniforms),s.side=bs;e[2].skinning=!0,this.materialsBackSide=e.map(s=>{const n=this.cloneMaterial(s);return n.uniforms=Object.assign({},t.uniforms),n.side=qe,n}),this.materialsDoubleSide=e.map(s=>{const n=this.cloneMaterial(s);return n.uniforms=Object.assign({},t.uniforms),n.side=be,n}),this.materialsFlatShaded=e.map(s=>{const n=this.cloneMaterial(s);return n.uniforms=Object.assign({},t.uniforms),n.flatShading=!0,n}),this.materialsFlatShadedBackSide=e.map(s=>{const n=this.cloneMaterial(s);return n.uniforms=Object.assign({},t.uniforms),n.flatShading=!0,n.side=qe,n}),this.materialsFlatShadedDoubleSide=e.map(s=>{const n=this.cloneMaterial(s);return n.uniforms=Object.assign({},t.uniforms),n.flatShading=!0,n.side=be,n})}}render(t,e,s){const n=t.shadowMap.enabled;if(t.shadowMap.enabled=!1,Et){const i=this.originalMaterials;this.meshCount=0,e.traverse(this.replaceMaterial),t.render(e,s);for(const o of i)o[0].material=o[1];this.meshCount!==i.size&&i.clear()}else{const i=e.overrideMaterial;e.overrideMaterial=this.material,t.render(e,s),e.overrideMaterial=i}t.shadowMap.enabled=n}disposeMaterials(){if(this.material!==null){const t=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const e of t)e.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return Et}static set workaroundEnabled(t){Et=t}},Ae=-1,Q=class extends Pt{constructor(t,e=Ae,s=Ae,n=1){super(),this.resizable=t,this.baseSize=new N(1,1),this.preferredSize=new N(e,s),this.target=this.preferredSize,this.s=n,this.effectiveSize=new N,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const t=this.baseSize,e=this.preferredSize,s=this.effectiveSize,n=this.scale;e.width!==Ae?s.width=e.width:e.height!==Ae?s.width=Math.round(e.height*(t.width/Math.max(t.height,1))):s.width=Math.round(t.width*n),e.height!==Ae?s.height=e.height:e.width!==Ae?s.height=Math.round(e.width/Math.max(t.width/Math.max(t.height,1),1)):s.height=Math.round(t.height*n)}get width(){return this.effectiveSize.width}set width(t){this.preferredWidth=t}get height(){return this.effectiveSize.height}set height(t){this.preferredHeight=t}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(t){this.s!==t&&(this.s=t,this.preferredSize.setScalar(Ae),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(t){this.scale=t}get baseWidth(){return this.baseSize.width}set baseWidth(t){this.baseSize.width!==t&&(this.baseSize.width=t,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(t){this.baseWidth=t}get baseHeight(){return this.baseSize.height}set baseHeight(t){this.baseSize.height!==t&&(this.baseSize.height=t,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(t){this.baseHeight=t}setBaseSize(t,e){(this.baseSize.width!==t||this.baseSize.height!==e)&&(this.baseSize.set(t,e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(t){this.preferredSize.width!==t&&(this.preferredSize.width=t,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(t){this.preferredWidth=t}get preferredHeight(){return this.preferredSize.height}set preferredHeight(t){this.preferredSize.height!==t&&(this.preferredSize.height=t,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(t){this.preferredHeight=t}setPreferredSize(t,e){(this.preferredSize.width!==t||this.preferredSize.height!==e)&&(this.preferredSize.set(t,e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(t){this.s=t.scale,this.baseSize.set(t.baseWidth,t.baseHeight),this.preferredSize.set(t.preferredWidth,t.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return Ae}},F={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},wr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",Pr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",Hr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",Ur="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Or="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",Lr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",_r="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",Jr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",Nr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",zr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",Kr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",kr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",Qr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",Xr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",jr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",Vr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",Yr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",Wr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",Zr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",qr="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",$r="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",eo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",to="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",so="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",no="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",io="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",ro="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",oo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",ao="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",co="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",lo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",uo="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",fo=new Map([[F.ADD,wr],[F.ALPHA,Pr],[F.AVERAGE,Hr],[F.COLOR,Ur],[F.COLOR_BURN,Or],[F.COLOR_DODGE,Lr],[F.DARKEN,_r],[F.DIFFERENCE,Jr],[F.DIVIDE,Nr],[F.DST,null],[F.EXCLUSION,zr],[F.HARD_LIGHT,Kr],[F.HARD_MIX,kr],[F.HUE,Qr],[F.INVERT,Xr],[F.INVERT_RGB,jr],[F.LIGHTEN,Vr],[F.LINEAR_BURN,Yr],[F.LINEAR_DODGE,Wr],[F.LINEAR_LIGHT,Zr],[F.LUMINOSITY,qr],[F.MULTIPLY,$r],[F.NEGATION,eo],[F.NORMAL,to],[F.OVERLAY,so],[F.PIN_LIGHT,no],[F.REFLECT,io],[F.SATURATION,ro],[F.SCREEN,oo],[F.SOFT_LIGHT,ao],[F.SRC,co],[F.SUBTRACT,lo],[F.VIVID_LIGHT,uo]]),ho=class extends Pt{constructor(t,e=1){super(),this._blendFunction=t,this.opacity=new w(e)}getOpacity(){return this.opacity.value}setOpacity(t){this.opacity.value=t}get blendFunction(){return this._blendFunction}set blendFunction(t){this._blendFunction=t,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(t){this.blendFunction=t}getShaderCode(){return fo.get(this.blendFunction)}},ct={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5},Ao=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,po="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",mo=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],go=class extends ee{constructor(t=new zt){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new w(null),texelSize:new w(new zt),scale:new w(1),kernel:new w(0)},blending:Te,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Ao,vertexShader:po}),this.fragmentShader=Ye(this.fragmentShader),this.setTexelSize(t.x,t.y),this.kernelSize=ct.MEDIUM}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setInputBuffer(t){this.inputBuffer=t}get kernelSequence(){return mo[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(t){this.uniforms.scale.value=t}getScale(){return this.uniforms.scale.value}setScale(t){this.uniforms.scale.value=t}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(t){this.uniforms.kernel.value=t}setKernel(t){this.kernel=t}setTexelSize(t,e){this.uniforms.texelSize.value.set(t,e,t*.5,e*.5)}setSize(t,e){const s=1/t,n=1/e;this.uniforms.texelSize.value.set(s,n,s*.5,n*.5)}},Bo=class extends Y{constructor({kernelSize:t=ct.MEDIUM,resolutionScale:e=.5,width:s=Q.AUTO_SIZE,height:n=Q.AUTO_SIZE,resolutionX:i=s,resolutionY:o=n}={}){super("KawaseBlurPass"),this.renderTargetA=new se(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const r=this.resolution=new Q(this,i,o,e);r.addEventListener("change",c=>this.setSize(r.baseWidth,r.baseHeight)),this._blurMaterial=new go,this._blurMaterial.kernelSize=t,this.copyMaterial=new $s}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(t){this._blurMaterial=t}get dithering(){return this.copyMaterial.dithering}set dithering(t){this.copyMaterial.dithering=t}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(t){this.blurMaterial.kernelSize=t}get width(){return this.resolution.width}set width(t){this.resolution.preferredWidth=t}get height(){return this.resolution.height}set height(t){this.resolution.preferredHeight=t}get scale(){return this.blurMaterial.scale}set scale(t){this.blurMaterial.scale=t}getScale(){return this.blurMaterial.scale}setScale(t){this.blurMaterial.scale=t}getKernelSize(){return this.kernelSize}setKernelSize(t){this.kernelSize=t}getResolutionScale(){return this.resolution.scale}setResolutionScale(t){this.resolution.scale=t}render(t,e,s,n,i){const o=this.scene,r=this.camera,c=this.renderTargetA,a=this.renderTargetB,l=this.blurMaterial,u=l.kernelSequence;let f=e;this.fullscreenMaterial=l;for(let d=0,h=u.length;d<h;++d){const A=d&1?a:c;l.kernel=u[d],l.inputBuffer=f.texture,t.setRenderTarget(A),t.render(o,r),f=A}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=f.texture,t.setRenderTarget(this.renderToScreen?null:s),t.render(o,r)}setSize(t,e){const s=this.resolution;s.setBaseSize(t,e);const n=s.width,i=s.height;this.renderTargetA.setSize(n,i),this.renderTargetB.setSize(n,i),this.blurMaterial.setSize(t,e)}initialize(t,e,s){s!==void 0&&(this.renderTargetA.texture.type=s,this.renderTargetB.texture.type=s,s!==xe?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):t!==null&&t.outputColorSpace===k&&(this.renderTargetA.texture.colorSpace=k,this.renderTargetB.texture.colorSpace=k))}static get AUTO_SIZE(){return Q.AUTO_SIZE}},vo=`#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l)*l;
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);
#else
gl_FragColor=vec4(l);
#endif
}`,Co=class extends ee{constructor(t=!1,e=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:Ke.replace(/\D+/g,"")},uniforms:{inputBuffer:new w(null),threshold:new w(0),smoothing:new w(1),range:new w(null)},blending:Te,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:vo,vertexShader:qs}),this.colorOutput=t,this.luminanceRange=e}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setInputBuffer(t){this.uniforms.inputBuffer.value=t}get threshold(){return this.uniforms.threshold.value}set threshold(t){this.smoothing>0||t>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=t}getThreshold(){return this.threshold}setThreshold(t){this.threshold=t}get smoothing(){return this.uniforms.smoothing.value}set smoothing(t){this.threshold>0||t>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=t}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(t){this.smoothing=t}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(t){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(t){t?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(t){return this.colorOutput}setColorOutputEnabled(t){this.colorOutput=t}get useRange(){return this.luminanceRange!==null}set useRange(t){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(t){t!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=t,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(t){this.luminanceRange=t}},Mo=class extends Y{constructor({renderTarget:t,luminanceRange:e,colorOutput:s,resolutionScale:n=1,width:i=Q.AUTO_SIZE,height:o=Q.AUTO_SIZE,resolutionX:r=i,resolutionY:c=o}={}){super("LuminancePass"),this.fullscreenMaterial=new Co(s,e),this.needsSwap=!1,this.renderTarget=t,this.renderTarget===void 0&&(this.renderTarget=new se(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const a=this.resolution=new Q(this,r,c,n);a.addEventListener("change",l=>this.setSize(a.baseWidth,a.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(t,e,s,n,i){const o=this.fullscreenMaterial;o.inputBuffer=e.texture,t.setRenderTarget(this.renderToScreen?null:this.renderTarget),t.render(this.scene,this.camera)}setSize(t,e){const s=this.resolution;s.setBaseSize(t,e),this.renderTarget.setSize(s.width,s.height)}initialize(t,e,s){s!==void 0&&s!==xe&&(this.renderTarget.texture.type=s,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},Eo=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`,xo="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",To=class extends ee{constructor(){super({name:"DownsamplingMaterial",uniforms:{inputBuffer:new w(null),texelSize:new w(new N)},blending:Te,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Eo,vertexShader:xo}),this.fragmentShader=Ye(this.fragmentShader)}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setSize(t,e){this.uniforms.texelSize.value.set(1/t,1/e)}},So=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`,yo="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",Ro=class extends ee{constructor(){super({name:"UpsamplingMaterial",uniforms:{inputBuffer:new w(null),supportBuffer:new w(null),texelSize:new w(new N),radius:new w(.85)},blending:Te,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:So,vertexShader:yo}),this.fragmentShader=Ye(this.fragmentShader)}set inputBuffer(t){this.uniforms.inputBuffer.value=t}set supportBuffer(t){this.uniforms.supportBuffer.value=t}get radius(){return this.uniforms.radius.value}set radius(t){this.uniforms.radius.value=t}setSize(t,e){this.uniforms.texelSize.value.set(1/t,1/e)}},bo=class extends Y{constructor(){super("MipmapBlurPass"),this.needsSwap=!1,this.renderTarget=new se(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Upsampling.Mipmap0",this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new To,this.upsamplingMaterial=new Ro,this.resolution=new N}get texture(){return this.renderTarget.texture}get levels(){return this.downsamplingMipmaps.length}set levels(t){if(this.levels!==t){const e=this.renderTarget;this.dispose(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[];for(let s=0;s<t;++s){const n=e.clone();n.texture.name="Downsampling.Mipmap"+s,this.downsamplingMipmaps.push(n)}this.upsamplingMipmaps.push(e);for(let s=1,n=t-1;s<n;++s){const i=e.clone();i.texture.name="Upsampling.Mipmap"+s,this.upsamplingMipmaps.push(i)}this.setSize(this.resolution.x,this.resolution.y)}}get radius(){return this.upsamplingMaterial.radius}set radius(t){this.upsamplingMaterial.radius=t}render(t,e,s,n,i){const{scene:o,camera:r}=this,{downsamplingMaterial:c,upsamplingMaterial:a}=this,{downsamplingMipmaps:l,upsamplingMipmaps:u}=this;let f=e;this.fullscreenMaterial=c;for(let d=0,h=l.length;d<h;++d){const A=l[d];c.setSize(f.width,f.height),c.inputBuffer=f.texture,t.setRenderTarget(A),t.render(o,r),f=A}this.fullscreenMaterial=a;for(let d=u.length-1;d>=0;--d){const h=u[d];a.setSize(f.width,f.height),a.inputBuffer=f.texture,a.supportBuffer=l[d].texture,t.setRenderTarget(h),t.render(o,r),f=h}}setSize(t,e){const s=this.resolution;s.set(t,e);let n=s.width,i=s.height;for(let o=0,r=this.downsamplingMipmaps.length;o<r;++o)n=Math.round(n*.5),i=Math.round(i*.5),this.downsamplingMipmaps[o].setSize(n,i),o<this.upsamplingMipmaps.length&&this.upsamplingMipmaps[o].setSize(n,i)}initialize(t,e,s){if(s!==void 0){const n=this.downsamplingMipmaps.concat(this.upsamplingMipmaps);for(const i of n)i.texture.type=s;if(s!==xe)this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1";else if(t!==null&&t.outputColorSpace===k)for(const i of n)i.texture.colorSpace=k}}dispose(){super.dispose();for(const t of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))t.dispose()}},It=class extends Pt{constructor(t,e,{attributes:s=ue.NONE,blendFunction:n=F.NORMAL,defines:i=new Map,uniforms:o=new Map,extensions:r=null,vertexShader:c=null}={}){super(),this.name=t,this.renderer=null,this.attributes=s,this.fragmentShader=e,this.vertexShader=c,this.defines=i,this.uniforms=o,this.extensions=r,this.blendMode=new ho(n),this.blendMode.addEventListener("change",a=>this.setChanged()),this._inputColorSpace=Ps,this._outputColorSpace=Hs}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(t){this._inputColorSpace=t,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t,this.setChanged()}set mainScene(t){}set mainCamera(t){}getName(){return this.name}setRenderer(t){this.renderer=t}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(t){this.attributes=t,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(t){this.fragmentShader=t,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(t){this.vertexShader=t,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(t,e=Ge){}update(t,e,s){}setSize(t,e){}initialize(t,e,s){}dispose(){for(const t of Object.keys(this)){const e=this[t];(e instanceof se||e instanceof Je||e instanceof it||e instanceof Y)&&this[t].dispose()}}},Fo=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}`,Do=class extends It{constructor({blendFunction:t=F.SCREEN,luminanceThreshold:e=.9,luminanceSmoothing:s=.025,mipmapBlur:n=!1,intensity:i=1,radius:o=.85,levels:r=8,kernelSize:c=ct.LARGE,resolutionScale:a=.5,width:l=Q.AUTO_SIZE,height:u=Q.AUTO_SIZE,resolutionX:f=l,resolutionY:d=u}={}){super("BloomEffect",Fo,{blendFunction:t,uniforms:new Map([["map",new w(null)],["intensity",new w(i)]])}),this.renderTarget=new se(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.blurPass=new Bo({kernelSize:c}),this.luminancePass=new Mo({colorOutput:!0}),this.luminanceMaterial.threshold=e,this.luminanceMaterial.smoothing=s,this.mipmapBlurPass=new bo,this.mipmapBlurPass.enabled=n,this.mipmapBlurPass.radius=o,this.mipmapBlurPass.levels=r,this.uniforms.get("map").value=n?this.mipmapBlurPass.texture:this.renderTarget.texture;const h=this.resolution=new Q(this,f,d,a);h.addEventListener("change",A=>this.setSize(h.baseWidth,h.baseHeight))}get texture(){return this.mipmapBlurPass.enabled?this.mipmapBlurPass.texture:this.renderTarget.texture}getTexture(){return this.texture}getResolution(){return this.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(t){this.resolution.preferredWidth=t}get height(){return this.resolution.height}set height(t){this.resolution.preferredHeight=t}get dithering(){return this.blurPass.dithering}set dithering(t){this.blurPass.dithering=t}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(t){this.blurPass.kernelSize=t}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(t){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(t){this.uniforms.get("intensity").value=t}getIntensity(){return this.intensity}setIntensity(t){this.intensity=t}getResolutionScale(){return this.resolution.scale}setResolutionScale(t){this.resolution.scale=t}update(t,e,s){const n=this.renderTarget,i=this.luminancePass;i.enabled?(i.render(t,e),this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(t,i.renderTarget):this.blurPass.render(t,i.renderTarget,n)):this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(t,e):this.blurPass.render(t,e,n)}setSize(t,e){const s=this.resolution;s.setBaseSize(t,e),this.renderTarget.setSize(s.width,s.height),this.blurPass.resolution.copy(s),this.luminancePass.setSize(t,e),this.mipmapBlurPass.setSize(t,e)}initialize(t,e,s){this.blurPass.initialize(t,e,s),this.luminancePass.initialize(t,e,s),this.mipmapBlurPass.initialize(t,e,s),s!==void 0&&(this.renderTarget.texture.type=s,t!==null&&t.outputColorSpace===k&&(this.renderTarget.texture.colorSpace=k))}},tn=class extends Y{constructor(t,e,s=null){super("RenderPass",t,e),this.needsSwap=!1,this.clearPass=new en,this.overrideMaterialManager=s===null?null:new us(s),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(t){this.scene=t}set mainCamera(t){this.camera=t}get renderToScreen(){return super.renderToScreen}set renderToScreen(t){super.renderToScreen=t,this.clearPass.renderToScreen=t}get overrideMaterial(){const t=this.overrideMaterialManager;return t!==null?t.material:null}set overrideMaterial(t){const e=this.overrideMaterialManager;t!==null?e!==null?e.setMaterial(t):this.overrideMaterialManager=new us(t):e!==null&&(e.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(t){this.overrideMaterial=t}get clear(){return this.clearPass.enabled}set clear(t){this.clearPass.enabled=t}getSelection(){return this.selection}setSelection(t){this.selection=t}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(t){this.ignoreBackground=t}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(t){this.skipShadowMapUpdate=t}getClearPass(){return this.clearPass}render(t,e,s,n,i){const o=this.scene,r=this.camera,c=this.selection,a=r.layers.mask,l=o.background,u=t.shadowMap.autoUpdate,f=this.renderToScreen?null:e;c!==null&&r.layers.set(c.getLayer()),this.skipShadowMapUpdate&&(t.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(o.background=null),this.clearPass.enabled&&this.clearPass.render(t,e),t.setRenderTarget(f),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(t,o,r):t.render(o,r),r.layers.mask=a,o.background=l,t.shadowMap.autoUpdate=u}},Io=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,Go="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",wo=class extends ee{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new w(null),normalBuffer:new w(null),texelSize:new w(new N)},blending:Te,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Io,vertexShader:Go})}set depthBuffer(t){this.uniforms.depthBuffer.value=t}set depthPacking(t){this.defines.DEPTH_PACKING=t.toFixed(0),this.needsUpdate=!0}setDepthBuffer(t,e=Ge){this.depthBuffer=t,this.depthPacking=e}set normalBuffer(t){this.uniforms.normalBuffer.value=t,t!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(t){this.normalBuffer=t}setTexelSize(t,e){this.uniforms.texelSize.value.set(t,e)}setSize(t,e){this.uniforms.texelSize.value.set(1/t,1/e)}},Po=class extends Y{constructor({normalBuffer:t=null,resolutionScale:e=.5,width:s=Q.AUTO_SIZE,height:n=Q.AUTO_SIZE,resolutionX:i=s,resolutionY:o=n}={}){super("DepthDownsamplingPass");const r=new wo;r.normalBuffer=t,this.fullscreenMaterial=r,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new se(1,1,{minFilter:ze,magFilter:ze,depthBuffer:!1,type:Gs}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const c=this.resolution=new Q(this,i,o,e);c.addEventListener("change",a=>this.setSize(c.baseWidth,c.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(t,e=Ge){this.fullscreenMaterial.depthBuffer=t,this.fullscreenMaterial.depthPacking=e}render(t,e,s,n,i){t.setRenderTarget(this.renderToScreen?null:this.renderTarget),t.render(this.scene,this.camera)}setSize(t,e){const s=this.resolution;s.setBaseSize(t,e),this.renderTarget.setSize(s.width,s.height),this.fullscreenMaterial.setSize(t,e)}initialize(t,e,s){const n=t.getContext();if(!(n.getExtension("EXT_color_buffer_float")||n.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},Ho=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,Uo="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",Oo=class extends ee{constructor(t,e,s,n,i=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:Ke.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new w(null),depthBuffer:new w(null),resolution:new w(new N),texelSize:new w(new N),cameraNear:new w(.3),cameraFar:new w(1e3),aspect:new w(1),time:new w(0)},blending:Te,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:i}),t&&this.setShaderParts(t),e&&this.setDefines(e),s&&this.setUniforms(s),this.copyCameraSettings(n)}set inputBuffer(t){this.uniforms.inputBuffer.value=t}setInputBuffer(t){this.uniforms.inputBuffer.value=t}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(t){this.uniforms.depthBuffer.value=t}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(t){this.defines.DEPTH_PACKING=t.toFixed(0),this.needsUpdate=!0}setDepthBuffer(t,e=Ge){this.depthBuffer=t,this.depthPacking=e}setShaderData(t){this.setShaderParts(t.shaderParts),this.setDefines(t.defines),this.setUniforms(t.uniforms),this.setExtensions(t.extensions)}setShaderParts(t){return this.fragmentShader=Ho.replace(I.FRAGMENT_HEAD,t.get(I.FRAGMENT_HEAD)||"").replace(I.FRAGMENT_MAIN_UV,t.get(I.FRAGMENT_MAIN_UV)||"").replace(I.FRAGMENT_MAIN_IMAGE,t.get(I.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=Uo.replace(I.VERTEX_HEAD,t.get(I.VERTEX_HEAD)||"").replace(I.VERTEX_MAIN_SUPPORT,t.get(I.VERTEX_MAIN_SUPPORT)||""),this.fragmentShader=Ye(this.fragmentShader),this.needsUpdate=!0,this}setDefines(t){for(const e of t.entries())this.defines[e[0]]=e[1];return this.needsUpdate=!0,this}setUniforms(t){for(const e of t.entries())this.uniforms[e[0]]=e[1];return this}setExtensions(t){this.extensions={};for(const e of t)this.extensions[e]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(t){this.encodeOutput!==t&&(t?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(t){return this.encodeOutput}setOutputEncodingEnabled(t){this.encodeOutput=t}get time(){return this.uniforms.time.value}set time(t){this.uniforms.time.value=t}setDeltaTime(t){this.uniforms.time.value+=t}adoptCameraSettings(t){this.copyCameraSettings(t)}copyCameraSettings(t){t&&(this.uniforms.cameraNear.value=t.near,this.uniforms.cameraFar.value=t.far,t instanceof Ss?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(t,e){const s=this.uniforms;s.resolution.value.set(t,e),s.texelSize.value.set(1/t,1/e),s.aspect.value=t/e}static get Section(){return I}};function fs(t,e,s){for(const n of e){const i="$1"+t+n.charAt(0).toUpperCase()+n.slice(1),o=new RegExp("([^\\.])(\\b"+n+"\\b)","g");for(const r of s.entries())r[1]!==null&&s.set(r[0],r[1].replace(o,i))}}function Lo(t,e,s){let n=e.getFragmentShader(),i=e.getVertexShader();const o=n!==void 0&&/mainImage/.test(n),r=n!==void 0&&/mainUv/.test(n);if(s.attributes|=e.getAttributes(),n===void 0)throw new Error(`Missing fragment shader (${e.name})`);if(r&&s.attributes&ue.CONVOLUTION)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);if(!o&&!r)throw new Error(`Could not find mainImage or mainUv function (${e.name})`);{const c=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,a=s.shaderParts;let l=a.get(I.FRAGMENT_HEAD)||"",u=a.get(I.FRAGMENT_MAIN_UV)||"",f=a.get(I.FRAGMENT_MAIN_IMAGE)||"",d=a.get(I.VERTEX_HEAD)||"",h=a.get(I.VERTEX_MAIN_SUPPORT)||"";const A=new Set,m=new Set;if(r&&(u+=`	${t}MainUv(UV);
`,s.uvTransformation=!0),i!==null&&/mainSupport/.test(i)){const v=/mainSupport *\([\w\s]*?uv\s*?\)/.test(i);h+=`	${t}MainSupport(`,h+=v?`vUv);
`:`);
`;for(const C of i.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const M of C[1].split(/\s*,\s*/))s.varyings.add(M),A.add(M),m.add(M);for(const C of i.matchAll(c))m.add(C[1])}for(const v of n.matchAll(c))m.add(v[1]);for(const v of e.defines.keys())m.add(v.replace(/\([\w\s,]*\)/g,""));for(const v of e.uniforms.keys())m.add(v);m.delete("while"),m.delete("for"),m.delete("if"),e.uniforms.forEach((v,C)=>s.uniforms.set(t+C.charAt(0).toUpperCase()+C.slice(1),v)),e.defines.forEach((v,C)=>s.defines.set(t+C.charAt(0).toUpperCase()+C.slice(1),v));const p=new Map([["fragment",n],["vertex",i]]);fs(t,m,s.defines),fs(t,m,p),n=p.get("fragment"),i=p.get("vertex");const B=e.blendMode;if(s.blendModes.set(B.blendFunction,B),o){e.inputColorSpace!==null&&e.inputColorSpace!==s.colorSpace&&(f+=e.inputColorSpace===k?`color0 = LinearTosRGB(color0);
	`:`color0 = sRGBToLinear(color0);
	`),e.outputColorSpace!==Hs?s.colorSpace=e.outputColorSpace:e.inputColorSpace!==null&&(s.colorSpace=e.inputColorSpace);const v=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;f+=`${t}MainImage(color0, UV, `,s.attributes&ue.DEPTH&&v.test(n)&&(f+="depth, ",s.readDepth=!0),f+=`color1);
	`;const C=t+"BlendOpacity";s.uniforms.set(C,B.opacity),f+=`color0 = blend${B.blendFunction}(color0, color1, ${C});

	`,l+=`uniform float ${C};

`}if(l+=n+`
`,i!==null&&(d+=i+`
`),a.set(I.FRAGMENT_HEAD,l),a.set(I.FRAGMENT_MAIN_UV,u),a.set(I.FRAGMENT_MAIN_IMAGE,f),a.set(I.VERTEX_HEAD,d),a.set(I.VERTEX_MAIN_SUPPORT,h),e.extensions!==null)for(const v of e.extensions)s.extensions.add(v)}}var _o=class extends Y{constructor(t,...e){super("EffectPass"),this.fullscreenMaterial=new Oo(null,null,null,t),this.listener=s=>this.handleEvent(s),this.effects=[],this.setEffects(e),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(t){for(const e of this.effects)e.mainScene=t}set mainCamera(t){this.fullscreenMaterial.copyCameraSettings(t);for(const e of this.effects)e.mainCamera=t}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(t){this.fullscreenMaterial.encodeOutput=t}get dithering(){return this.fullscreenMaterial.dithering}set dithering(t){const e=this.fullscreenMaterial;e.dithering=t,e.needsUpdate=!0}setEffects(t){for(const e of this.effects)e.removeEventListener("change",this.listener);this.effects=t.sort((e,s)=>s.attributes-e.attributes);for(const e of this.effects)e.addEventListener("change",this.listener)}updateMaterial(){const t=new Gr;let e=0;for(const r of this.effects)if(r.blendMode.blendFunction===F.DST)t.attributes|=r.getAttributes()&ue.DEPTH;else{if(t.attributes&r.getAttributes()&ue.CONVOLUTION)throw new Error(`Convolution effects cannot be merged (${r.name})`);Lo("e"+e++,r,t)}let s=t.shaderParts.get(I.FRAGMENT_HEAD),n=t.shaderParts.get(I.FRAGMENT_MAIN_IMAGE),i=t.shaderParts.get(I.FRAGMENT_MAIN_UV);const o=/\bblend\b/g;for(const r of t.blendModes.values())s+=r.getShaderCode().replace(o,`blend${r.blendFunction}`)+`
`;t.attributes&ue.DEPTH?(t.readDepth&&(n=`float depth = readDepth(UV);

	`+n),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,t.colorSpace===k&&(n+=`color0 = sRGBToLinear(color0);
	`),t.uvTransformation?(i=`vec2 transformedUv = vUv;
`+i,t.defines.set("UV","transformedUv")):t.defines.set("UV","vUv"),t.shaderParts.set(I.FRAGMENT_HEAD,s),t.shaderParts.set(I.FRAGMENT_MAIN_IMAGE,n),t.shaderParts.set(I.FRAGMENT_MAIN_UV,i);for(const[r,c]of t.shaderParts)c!==null&&t.shaderParts.set(r,c.trim().replace(/^#/,`
#`));this.skipRendering=e===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(t)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(t,e=Ge){this.fullscreenMaterial.depthBuffer=t,this.fullscreenMaterial.depthPacking=e;for(const s of this.effects)s.setDepthTexture(t,e)}render(t,e,s,n,i){for(const o of this.effects)o.update(t,e,n);if(!this.skipRendering||this.renderToScreen){const o=this.fullscreenMaterial;o.inputBuffer=e.texture,o.time+=n*this.timeScale,t.setRenderTarget(this.renderToScreen?null:s),t.render(this.scene,this.camera)}}setSize(t,e){this.fullscreenMaterial.setSize(t,e);for(const s of this.effects)s.setSize(t,e)}initialize(t,e,s){this.renderer=t;for(const n of this.effects)n.initialize(t,e,s);this.updateMaterial(),s!==void 0&&s!==xe&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const t of this.effects)t.removeEventListener("change",this.listener),t.dispose()}handleEvent(t){switch(t.type){case"change":this.recompile();break}}},Jo=class extends Y{constructor(t,e,{renderTarget:s,resolutionScale:n=1,width:i=Q.AUTO_SIZE,height:o=Q.AUTO_SIZE,resolutionX:r=i,resolutionY:c=o}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new tn(t,e,new Vn);const a=this.renderPass;a.ignoreBackground=!0,a.skipShadowMapUpdate=!0;const l=a.getClearPass();l.overrideClearColor=new ie(7829503),l.overrideClearAlpha=1,this.renderTarget=s,this.renderTarget===void 0&&(this.renderTarget=new se(1,1,{minFilter:ze,magFilter:ze}),this.renderTarget.texture.name="NormalPass.Target");const u=this.resolution=new Q(this,r,c,n);u.addEventListener("change",f=>this.setSize(u.baseWidth,u.baseHeight))}set mainScene(t){this.renderPass.mainScene=t}set mainCamera(t){this.renderPass.mainCamera=t}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(t){this.resolution.scale=t}render(t,e,s,n,i){const o=this.renderToScreen?null:this.renderTarget;this.renderPass.render(t,o,o)}setSize(t,e){const s=this.resolution;s.setBaseSize(t,e),this.renderTarget.setSize(s.width,s.height)}};let Oe;function No(){var t;if(Oe!==void 0)return Oe;try{let e;const s=document.createElement("canvas");return Oe=!!(window.WebGL2RenderingContext&&(e=s.getContext("webgl2"))),e&&((t=e.getExtension("WEBGL_lose_context"))==null||t.loseContext()),Oe}catch{return Oe=!1}}const zo=g.createContext(null),ds=t=>(t.getAttributes()&ue.CONVOLUTION)===ue.CONVOLUTION,Ko=Rt.memo(g.forwardRef(({children:t,camera:e,scene:s,resolutionScale:n,enabled:i=!0,renderPriority:o=1,autoClear:r=!0,depthBuffer:c,disableNormalPass:a,stencilBuffer:l,multisampling:u=8,frameBufferType:f=Ds},d)=>{const{gl:h,scene:A,camera:m,size:p}=z(),B=s||A,v=e||m,[C,M,E]=g.useMemo(()=>{const b=No(),G=new Ir(h,{depthBuffer:c,stencilBuffer:l,multisampling:u>0&&b?u:0,frameBufferType:f});G.addPass(new tn(B,v));let U=null,O=null;return a||(O=new Jo(B,v),O.enabled=!1,G.addPass(O),n!==void 0&&b&&(U=new Po({normalBuffer:O.texture,resolutionScale:n}),U.enabled=!1,G.addPass(U))),[G,O,U]},[v,h,c,l,u,f,B,a,n]);g.useEffect(()=>C==null?void 0:C.setSize(p.width,p.height),[C,p]),q((b,G)=>{if(i){const U=h.autoClear;h.autoClear=r,l&&!r&&h.clearStencil(),C.render(G),h.autoClear=U}},i?o:0);const S=g.useRef(null),R=Wn(S);g.useLayoutEffect(()=>{const b=[];if(S.current&&R.current&&C){const G=R.current.objects;for(let U=0;U<G.length;U++){const O=G[U];if(O instanceof It){const W=[O];if(!ds(O)){let re=null;for(;(re=G[U+1])instanceof It&&!ds(re);)W.push(re),U++}const _=new _o(v,...W);b.push(_)}else O instanceof Y&&b.push(O)}for(const U of b)C==null||C.addPass(U);M&&(M.enabled=!0),E&&(E.enabled=!0)}return()=>{for(const G of b)C==null||C.removePass(G);M&&(M.enabled=!1),E&&(E.enabled=!1)}},[C,t,v,M,E,R]);const T=g.useMemo(()=>({composer:C,normalPass:M,downSamplingPass:E,resolutionScale:n,camera:v,scene:B}),[C,M,E,n,v,B]);return g.useImperativeHandle(d,()=>C,[C]),y.jsx(zo.Provider,{value:T,children:y.jsx("group",{ref:S,children:t})})}));let ko=0;const hs=new WeakMap,Qo=(t,e)=>Rt.forwardRef(function({blendFunction:n=e==null?void 0:e.blendFunction,opacity:i=e==null?void 0:e.opacity,...o},r){let c=hs.get(t);if(!c){const u=`@react-three/postprocessing/${t.name}-${ko++}`;ws({[u]:t}),hs.set(t,c=u)}const a=z(u=>u.camera),l=Rt.useMemo(()=>{var u,f;return[...(u=e==null?void 0:e.args)!=null?u:[],...(f=o.args)!=null?f:[{...e,...o}]]},[JSON.stringify(o)]);return y.jsx(c,{camera:a,"blendMode-blendFunction":n,"blendMode-opacity-value":i,...o,ref:r,args:l})}),Xo=Qo(Do,{blendFunction:F.ADD}),jo=()=>y.jsx(y.Fragment,{children:y.jsx(Ko,{renderPriority:2,children:y.jsx(Xo,{intensity:3.5,kernelSize:ct.VERY_LARGE,luminanceThreshold:.2,luminanceSmoothing:.001,mipmapBlur:!1})})}),Re=new V,sn="logo_Ithaca/3D_logo_Ithaca.gltf";Ve.preload(sn);const Vo=({modelPath:t=sn})=>{const{scene:e}=Ve(t),s=g.useRef(null),n=g.useRef(),i=g.useRef(),o=g.useMemo(()=>we(window.innerWidth),[]),{logoScale:r,logoEnableMouseReaction:c,blobMoveX:a,blobMoveY:l}=o,u=at(),f=Xe(),d=g.useCallback(A=>{A.transparent=!0,A.depthTest=!1,A.depthWrite=!1,A.roughness=.6,A.metalness=.8,A.onBeforeCompile=m=>{m.uniforms.logoOut={value:1},m.fragmentShader=`
        uniform float logoOut;
        ${m.fragmentShader}
      `.replace("#include <dithering_fragment>",`
          #include <dithering_fragment>
          gl_FragColor.a *= logoOut;
        `),i.current=m,n.current=A}},[]);g.useEffect(()=>(e.renderOrder=999,e.traverse(A=>{A!=null&&A.material&&d(A.material)}),()=>{e.traverse(A=>{A!=null&&A.material&&A.material.dispose(),A!=null&&A.geometry&&A.geometry.dispose()})}),[e,d]),q(({pointer:A})=>{if(!s.current||!i.current)return;const m=s.current,p=i.current,B=f.scrollData.get(),v=1-B.logoOut,C=1-B.logoAlphaOut,M=Math.min(B.logoAlphaOut*6,1),E=window.innerWidth<=1024?B.blobMobilePosY:0;c&&Re.set(Ue(Re.x,A.y/-1.5,.1),Ue(Re.y,A.x/1.5,.1),0),m.rotation.set(Ue(Re.x,0,M),Ue(Re.y,0,M),Ue(Re.z,0,M));const S=1+(v-1);m.scale.setScalar(S),m.position.set(a*B.blobPosX*u,l*B.blobPosY*u+l*u*E,(v-1)*u);const R=Math.pow(C,5);p.uniforms.logoOut.value=R,m.visible&&R<=.001?m.visible=!1:!m.visible&&R>.001&&(m.visible=!0)});const h=g.useMemo(()=>[r*u,r*u,r*u],[r,u]);return y.jsx("group",{ref:s,children:y.jsx("primitive",{scale:h,position:[0,0,0],object:e})})},Yo=`
    vec3 normalizeColor(vec3 color) {
        return vec3(color.r/255., color.g/255., color.b/255.);
    }
`,Wo=({material:t})=>{t.roughness=.4,t.metalness=.4,t.transparent=!0,t.depthTest=!1;const e={value:null};return t.onBeforeCompile=n=>{n.uniforms.iTime={value:0},n.uniforms.resolution={value:{x:window.innerWidth,y:window.innerHeight}},n.uniforms.baseColor={value:{r:0,g:.5,b:.2}},n.uniforms.universeIn={value:0},n.uniforms.universeOut={value:0},n.uniforms.uPixelRatio={value:Math.min(window.devicePixelRatio,2)},n.vertexShader=`
            uniform float iTime;
            uniform float universeIn;
            uniform float uPixelRatio;

            varying vec2 vUv;
            varying vec3 vPosition;

            attribute float size;
            attribute float used;
            attribute vec3 color;

            varying float vUsed;
            varying vec3 vColor;
            

        `+n.vertexShader.replace("void main() {",`
            void main() {
                vec3 newPosition = position;
                vUv = uv;
                vNormal = normal;
                vPosition = newPosition;
                vUsed = used;
                vColor = color;
        `),n.vertexShader=n.vertexShader.replace("#include <fog_vertex>",`
            #include <fog_vertex>
            gl_PointSize = size * uPixelRatio * 0.5;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        `),n.fragmentShader=`
            uniform float iTime;
            uniform vec3 baseColor;
            uniform float universeIn;
            uniform float universeOut;
            varying vec2 vUv;
            varying vec3 vPosition;
            varying float vUsed;
            varying vec3 vColor;

            ${Yo}

            

        `+n.fragmentShader.replace("void main() {",`
            void main() {
        `),n.fragmentShader=n.fragmentShader.replace("#include <dithering_fragment>",`
            #include <dithering_fragment>

            // Make Points Rounded
            vec2 pointUV = gl_PointCoord * 2.0 - 1.0;
            float distance = length(pointUV);
            float threshold = 0.8;
            if (distance >= threshold) {
                discard;
            }

            float inAlpha = clamp((universeIn - .5) * 4., 0., 1.);
            float outAlpha = clamp((1. - (universeOut - .5)*2.5), 0., 1.);

            vec3 color = normalizeColor(vColor);
            gl_FragColor = vec4(color, vUsed * inAlpha * outAlpha);
        `),e.value=n},{instance:t,render:n=>{e.value&&(e.value.uniforms.iTime.value=n)},shader:e}};function As({material:t}){const e=new ke,s=we(window.innerWidth),n=3,i=.01*n,o=s.universeMaxPointsPerRenderFrame,r=s.universeDensity,c=.006*n,a=1e-5*n,l=.002,u=s.universeInitialRadius,f=.08,d=30,h=s.universeMinPointSize,A=s.universeMaxPointSize,m=.8,p=[{r:95,g:133,b:124},{r:92,g:59,b:138},{r:98,g:113,b:139}];function B(){const L=Math.random();return L<.6?p[0]:L<.8?p[1]:p[2]}const v=.0015*n,C=.01,M=[],E=[],S=[],R=[],T=[],b=[],G=[],U=[],O=[],W=[],_={value:!1};for(let L=0;L<r;L++){const{x:J,y:P,z:te}=re(1);E.push(J,P,te),S.push(J,P,te),M.push(vr(h,A)),R.push(0),b.push(0),G.push(0),U.push(c),O.push(!1),T.push(Math.random()+.1,Math.random()+.1,Math.random()+.1);const X=B();W.push(X.r,X.g,X.b)}function re(L){const J=Math.random(),P=Math.random(),te=2*Math.PI*J,X=Math.acos(2*P-1),Se=L*Math.sin(X)*Math.cos(te),ye=L*Math.sin(X)*Math.sin(te),x=L*Math.cos(X);let j=Math.random();j=Math.random()<.3?j*d:j;const Be=Math.cbrt(Math.pow(j*f,1))*L;return{x:Se*Be,y:ye*Be,z:x*Be}}e.setAttribute("position",new ae(E,3)),e.setAttribute("size",new ae(M,1)),e.setAttribute("used",new ae(R,1)),e.setAttribute("color",new ae(W,3));const K=new Gt(e,t.instance);K.visible=!1;const fe={value:0},lt=L=>{if(!_.value)return;const J=K.geometry.attributes.position.array,P=K.geometry.attributes.used.array,te=Xe().scrollData.get().universeOut;if(te>.5){for(let x=0;x<E.length;x+=3){const j=(te-.5)*2;J[x]=S[x]+S[x]*T[x]*10*j,J[x+1]=S[x+1]+S[x+1]*T[x+1]*10*j,J[x+2]=S[x+2]+S[x+2]*T[x+2]*10*j}K.geometry.attributes.position.needsUpdate=!0;return}t.render(L);const X=new V(u,0,0),Se=o;let ye=0;fe.value+=i;for(let x=0;x<E.length;x+=3){const j=E[x],ne=E[x+2],ft=new V(j,0,ne).clone().sub(X).length();if(P[x/3]===0&&ye<Se){const nn=Math.cos(fe.value)*ft*m,rn=Math.sin(fe.value)*ft;S[x]=J[x]=nn,S[x+1]=J[x+1]=E[x+1],S[x+2]=J[x+2]=rn,ye++,P[x/3]=1e-4,b[x/3]=fe.value,G[x/3]=ft,O[x/3]=!0,U[x/3]=c}O[x/3]&&(P[x/3]=Math.min(P[x/3]+C,1),P[x/3]===1&&(O[x/3]=!1)),P[x/3]>0&&(G[x/3]+=U[x/3],b[x/3]+=T[x/3]/1e3,U[x/3]=Math.max(U[x/3]-a,l),S[x]=J[x]=Math.cos(b[x/3])*G[x/3]*m,S[x+1]=J[x+1]=E[x+1],S[x+2]=J[x+2]=Math.sin(b[x/3])*G[x/3],O[x/3]||(P[x/3]=Math.max(P[x/3]-v,0)))}K.geometry.attributes.position.needsUpdate=!0,K.geometry.attributes.used.needsUpdate=!0},We=()=>{fe.value=0;const L=K.geometry.attributes.position.array,J=K.geometry.attributes.used.array;for(let P=0;P<E.length;P+=3)J[P/3]=0,O[P/3]=!1,L[P]=E[P],L[P+1]=E[P+1],L[P+2]=E[P+2];K.geometry.attributes.position.needsUpdate=!0,K.geometry.attributes.used.needsUpdate=!0},Ze=()=>{_.value=!0,K.visible=!0},H=()=>{We(),_.value=!1,K.visible=!1};return{points:K,render:lt,shader:t.shader,startRender:Ze,stopRender:H}}const Zo=()=>g.useMemo(()=>{const t=Wo({material:new $});t.instance.toneMapped=!1;const e=As({material:t}),s=As({material:t}),n=new Ne;n.add(e.points),n.add(s.points),s.points.rotation.y=Math.PI,n.rotation.set(1,-1,.5);const i=a=>{e.render(a),s.render(a)},o=()=>{e.startRender(),s.startRender()},r=()=>{e.stopRender(),s.stopRender()},c=t.shader;return{mesh:n,render:i,shader:c,startRender:o,stopRender:r}},[]),qo=()=>{const t=Zo(),e=Xe(),s=g.useRef(!1);q(({clock:i})=>{var c,a;t.render(i.getElapsedTime());const o=e.scrollData.get();(c=t.shader.value)!=null&&c.uniforms.universeIn&&(t.shader.value.uniforms.universeIn.value=o.universeIn),(a=t.shader.value)!=null&&a.uniforms.universeOut&&(t.shader.value.uniforms.universeOut.value=o.universeOut),!s.current&&o.universeIn>=.5&&(s.current=!0,t.startRender()),s.current&&o.universeIn<.5&&(s.current=!1,t.stopRender());const r=.3+o.universeScale;t.mesh.scale.set(r,r,r)});const n=at();return y.jsx("group",{scale:[n,n,n],children:y.jsx("primitive",{object:t.mesh})})},$o=()=>y.jsxs(y.Fragment,{children:[y.jsx("directionalLight",{color:16777215,intensity:.2,position:[-5,0,10]}),y.jsx("directionalLight",{color:16777215,intensity:.2,position:[5,0,10]})]}),ea=`
    // Gold Noise 2015 dcerisano@standard3d.com
    // - based on the Golden Ratio
    // - uniform normalized distribution
    // - fastest static noise generator function (also runs at low precision)
    // - use with indicated fractional seeding method. 

    float PHI = 1.61803398874989484820459;  //  = Golden Ratio   

    float goldNoise(in vec2 xy, in float seed){
        return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
    }
`,ta=()=>{const t={uTime:{value:0},uPositionZ:{value:3},uPositionY:{value:0},uPixelRatio:{value:Math.min(window.devicePixelRatio,2)}},e=`
        attribute vec3 color;
        attribute float size;
        varying vec3 vColor;
        varying vec2 vUv;
        varying vec3 vPosition;

        uniform float uPositionZ;
        uniform float uPositionY;
        uniform float uPixelRatio;
        uniform float uTime;

        void main() {
            vColor = color;
            vUv = uv;

            vec3 newPos = position;
            vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            gl_PointSize = size * uPixelRatio * 5.;
            vPosition = newPos;
        }
    `,s=`
        varying vec3 vColor;
        varying vec2 vUv;
        uniform float uTime;
        varying vec3 vPosition;

        ${ea}

        void main() {
            float dist = length(gl_PointCoord - vec2(0.5, 0.5));
            float alpha = pow(1. - smoothstep(.00001, .3, dist), 3.);
            float fakeBloom = .05 * (1. - smoothstep(.3, .4, dist));
            float blink = (sin(uTime / 4. * goldNoise(vec2(vPosition.x, vPosition.x), 1.) * 5.) + 1.25) / 2.;

            gl_FragColor = vec4(vec3(.8, .8, .8)*2., (alpha + fakeBloom) * blink);
        }
    `;return new ee({uniforms:t,vertexShader:e,fragmentShader:s,depthWrite:!1,toneMapped:!1,transparent:!0})},sa=()=>{const t=g.useRef(null),e=g.useRef(null),s=g.useMemo(()=>ta(),[]),{starsCloseDensity:n,starsFarDensity:i,starsFlowSpeed:o,starsEnbaleMouseReaction:r}=g.useMemo(()=>we(window.innerWidth),[]);q(({clock:f,pointer:d})=>{if(t.current.rotation.z+=1e-4,s.uniforms.uTime.value=f.getElapsedTime(),!e.current||!r)return;const h=d.y*.2,A=d.x*.2;e.current.position.y=pe.lerp(e.current.position.y,h,.075),e.current.position.x=pe.lerp(e.current.position.x,A,.075)}),q(({camera:f})=>{const d=e.current;if(!d)return;const h=d.geometry.attributes.position.array;for(let A=0;A<h.length;A+=3)h[A+2]+=o,h[A+2]>f.position.z&&(h[A+2]=0)});const c=g.useMemo(()=>new Float32Array(Array.from({length:n*3},(f,d)=>pe.randFloat(-10,10))),[n]),a=g.useMemo(()=>new Float32Array(Array.from({length:n},()=>pe.randFloat(.1,2))),[n]),l=g.useMemo(()=>Array.from({length:i},f=>[pe.randFloatSpread(30),pe.randFloatSpread(30),pe.randFloat(2,8)]),[i]),u=1;return y.jsxs("group",{scale:[u,u,u],children:[y.jsxs(cs,{ref:t,limit:i,range:i,children:[y.jsx(lr,{transparent:!0,vertexColors:!0,size:1,sizeAttenuation:!1,depthWrite:!1,toneMapped:!1}),l.map((f,d)=>y.jsx(hr,{position:f,color:"white"},d))]}),y.jsx(cs,{name:"close-stars",ref:e,positions:c,sizes:a,material:s})]})},na=`varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

void main() {
    vUv = uv;
    vNormal = normal;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`,ia=`varying vec2 vUv;
uniform float posX;
uniform float posY;
uniform float radius;
uniform float colorDetector;
uniform float isHovered;
uniform float mouseX;
uniform float mouseY;
uniform float gridOut;


float getRectangle(vec2 offset, vec2 uv, float edge, float widthX, float heightY) {
    // Rotation angle in radians (30 degrees)
    float angle = radians(45.0);

    uv.x += offset.x;
    uv.y += offset.y;

    // Rotation matrix components
    float s = sin(angle);
    float c = cos(angle);

    // Calculate rotated coordinates
    float rotatedX = c * (uv.x - posX) - s * (uv.y - posY) + posX;
    float rotatedY = s * (uv.x - posX) + c * (uv.y - posY) + posY;

    // Crop Rectangle
    float rectangleAlphaX = smoothstep(posX - widthX - edge, posX - widthX + edge, rotatedX) - smoothstep(posX + widthX - edge, posX + widthX + edge, rotatedX);
    float rectangleAlphaY = smoothstep(posY - heightY - edge, posY - heightY + edge , rotatedY) - smoothstep(posY + heightY - edge, posY + heightY + edge, rotatedY);
    float rectangleAlpha = rectangleAlphaX * rectangleAlphaY;

    return rectangleAlpha;
}


void main() {
    vec2 invertedUV = vec2(1.0 - vUv.x, 1.0 - vUv.y);

    // Outline Alpha
    float width = 0.015;
    float outline1 = step(0.0+width/2.0, invertedUV.y) * step(invertedUV.y, 1.0-width/2.0);
    float outline2 = step(0.0+width/2.0, invertedUV.x) * step(invertedUV.x, 1.0-width/2.0);
    float outline3 = step(0.0+width/2.0, 1.0 - invertedUV.y) * step(invertedUV.y, 1.0-width/2.0);
    float outline4 = step(0.0+width/2.0, 1.0 - invertedUV.x) * step(invertedUV.x, 1.0-width/2.0);
    float outlineAlpha = 1. - outline1 * outline2 * outline3 * outline4;

    // Fill Alpha 
    float fillAlpha = step(0.85, colorDetector);
    fillAlpha -= fillAlpha * outlineAlpha;

    // Fill Outline Part & Inner Part
    vec3 outlineColor = vec3(1.0, 1.0, 1.0);
    vec3 outlineActiveColor = vec3(0.25, 1.0*1.5, 0.29*2.);
    vec3 fillColor = vec3(0.55, 1.0, 0.89);

    float outlineEdge = 0.3;

    if(isHovered != 0.0 && colorDetector > 0.85){
        fillAlpha = fillAlpha * (1.0 - isHovered);
        outlineColor = mix(outlineColor, outlineActiveColor, isHovered);
        outlineEdge *= (1.0 + isHovered * 4.);
    }

    outlineColor *= outlineAlpha * outlineEdge;
    fillColor *= fillAlpha * 0.2;

    
    // Get Rectangle Alpha
    float rectangleLeft = getRectangle(vec2(5., 0.), invertedUV, 2.5, 2.0, 2.0);
    float rectangleRight = getRectangle(vec2(-5., 0.), invertedUV, 2.5, 2.0, 2.0);
    float rectangleAlpha = rectangleLeft + rectangleRight;

    //get second Alpha
    float mouseRectangleAlpha = getRectangle(vec2(mouseX, mouseY), invertedUV, 1.5, 1.0, 1.0) * 1.0;
    // Rectangle Top Right / to remove hover effect there
    float rectangleTopRightMask = getRectangle(vec2(7., 5.), invertedUV, .5, 4.0, 4.0);
    mouseRectangleAlpha *= (1. - rectangleTopRightMask);

    float allRectanglesAlpha = min(mouseRectangleAlpha + rectangleAlpha, 1.0);

    float alpha = (outlineAlpha + fillAlpha) * (allRectanglesAlpha);
    vec3 color = fillColor + outlineColor;

    float speedOut = max((1.0-gridOut*(colorDetector+1.)), 0.);

    gl_FragColor = vec4(color, alpha*speedOut);
}`,ra=`varying vec2 vUv;
varying vec3 vNormal;

void main() {
    vUv = uv;
    vNormal = normal;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,oa=`varying vec2 vUv;
uniform float uTime;
uniform float startTime;
uniform float fadeInDuration;
uniform float direction;
uniform float gridOut;
uniform float colorDetector;
uniform float isHovered;
uniform float rotation;

void main() {
    vec2 invertedUV = vec2(1.0 - vUv.x, 1.0 - vUv.y);

    float width = 0.01;
    float outline1 = step(0.0 + width / 2.0, invertedUV.y) * step(invertedUV.y, 1.0 - width / 2.0);
    float outline2 = step(0.0 + width / 2.0, invertedUV.x) * step(invertedUV.x, 1.0 - width / 2.0);
    float outline3 = step(0.0 + width / 2.0, 1.0 - invertedUV.y) * step(invertedUV.y, 1.0 - width / 2.0);
    float outline4 = step(0.0 + width / 2.0, 1.0 - invertedUV.x) * step(invertedUV.x, 1.0 - width / 2.0);
    float outline = outline1 * outline2 * outline3 * outline4;

    float offset = isHovered * 0.3;

    float circlePos;

    //Direction
    direction == -1.0 ? circlePos = 1.0 - fract(offset + startTime) : circlePos = mod(offset + startTime, 1.0);

    float circleRadius = 0.3;
    float smallCircleRadius = 0.03;



    vec2 circleCenter;
    vec2 circleSmall1Center;
    vec2 circleSmall2Center;

    float circleOffset = 0.10;

    if (circlePos < 0.25) {
        circleCenter = vec2(circlePos * 4.0, 0.0);
        circleSmall1Center = circleCenter - vec2(circleOffset, 0.);
        circleSmall2Center = circleCenter + vec2(circleOffset, 0.);
    } else if (circlePos < 0.5) {
        circleCenter = vec2(1.0, (circlePos - 0.25) * 4.0);
        circleSmall1Center = circleCenter - vec2(0.0, circleOffset);
        circleSmall2Center = circleCenter + vec2(0.0, circleOffset);
    } else if (circlePos < 0.75) {
        circleCenter = vec2(1.0 - (circlePos - 0.5) * 4.0, 1.0);
        circleSmall1Center = circleCenter - vec2(-circleOffset, 0.0);
        circleSmall2Center = circleCenter + vec2(-circleOffset, 0.0);
    } else {
        circleCenter = vec2(0.0, 1.0 - (circlePos - 0.75) * 4.0);
        circleSmall1Center = circleCenter - vec2(0.0, -circleOffset);
        circleSmall2Center = circleCenter + vec2(0.0, -circleOffset);
    }

    float distanceToCircle = length(invertedUV - circleCenter) + 0.52;
    float distanceToCircle1Small = length(invertedUV - circleSmall1Center);
    float distanceToCircle2Small = length(invertedUV - circleSmall2Center);


    float insideOpacity = 0.0;
    float outsideOpacity = 1.0;
    float opacity = mix(outsideOpacity, insideOpacity, outline);

    vec3 circleColor = vec3(0.25, 1.0, 0.29) * .5;

    float finalAlpha = smoothstep(distanceToCircle - 0.5, distanceToCircle - 0.5 + 0.2, circleRadius);
 
    float smallerCircle1 = smoothstep(distanceToCircle1Small, distanceToCircle1Small + 0.0001, smallCircleRadius);
    float smallerCircle2 = smoothstep(distanceToCircle2Small, distanceToCircle2Small + 0.0001, smallCircleRadius);


    finalAlpha = max(finalAlpha - (smallerCircle1 + smallerCircle2), 0.0);
    float speedOut = max((1.0-gridOut*2.), 0.);

    float isVisible = 0.0;

    // if(isHovered > 0.0 && isHovered < 2.0) {
    // }
    isVisible = mix(0.0, 1.0, 3. - isHovered);


    float alpha = opacity*finalAlpha*speedOut*isVisible;

    if(colorDetector < 0.85) {
        circleColor = vec3(0.0);
        alpha = 0.0;
    }

    

    gl_FragColor = vec4(circleColor, alpha);
}`;function aa(){return g.useMemo(()=>{const r={value:0},c={value:0},a={value:0},l={value:0},u=()=>{const d=[],h=[[-8.5,.5],[-7.5,-.5],[-6.5,2.5],[-4.5,3.5],[8.5,.5],[7.5,3.5],[4.5,2.5],[7.5,-.5],[5.5,.5],[9.5,4.5]],A=new Ht(1*1,1*1);for(let m=0;m<30;m++)for(let p=0;p<30;p++){const B=-14.5+m*1,v=-14.5+p*1,C=h.some(([b,G])=>b===B&&G===v);let M;C?M=1.9:M=.5;const E=Math.floor(Math.random()*3.5)*Math.PI/2,S=new ee({transparent:!0,vertexShader:na,fragmentShader:ia,depthTest:!0,depthWrite:!0,uniforms:{colorDetector:{value:M},posX:{value:B},posY:{value:v},radius:{value:5},isHovered:{value:0},gridOut:r,mouseX:c,mouseY:a}}),{hoverMesh:R}=ca(B*1,v*1,r,l,M,E),T=new Qe(A,S);T.position.set(B,v,0),T.userData.position={x:B,y:v*-1},R.rotation.z=E,d.push([T,R])}return{meshes:d,mouseX:c,mouseY:a}},{meshes:f}=u();return{meshes:f,gridOut:r,mouseX:c,mouseY:a,griduTime:l}},[])}function ca(t,e,s,n,i,o){const r=Math.random()>.5?3:2;let c=r===2?t-.5:t-1,a=r===2?e-.5:e-1;const l=o*2/Math.PI;l===1?c+=r===2?1:2:l===2?(c+=r===2?1:2,a+=r===2?1:2):l===3&&(a+=r===2?1:2);const u=new Ht(r*1,r*1),f=new ee({transparent:!0,vertexShader:ra,fragmentShader:oa,depthTest:!0,depthWrite:!0,uniforms:{posX:{value:c},posY:{value:a},gridOut:s,rotation:{value:o},uTime:n,isHovered:{value:3},colorDetector:{value:i}}}),d=new Qe(u,f);return d.position.set(c,a,0),{hoverMesh:d}}const la=`varying vec2 vUv;
varying vec3 vNormal;

void main() {
    vUv = uv;
    vNormal = normal;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,ua=`varying vec2 vUv;
uniform float uTime;
uniform float startTime;
uniform float fadeInDuration;
uniform float direction;
uniform float gridOut;

void main() {
    vec2 invertedUV = vec2(1.0 - vUv.x, 1.0 - vUv.y);

    float width = 0.015;
    float outline1 = step(0.0 + width / 2.0, invertedUV.y) * step(invertedUV.y, 1.0 - width / 2.0);
    float outline2 = step(0.0 + width / 2.0, invertedUV.x) * step(invertedUV.x, 1.0 - width / 2.0);
    float outline3 = step(0.0 + width / 2.0, 1.0 - invertedUV.y) * step(invertedUV.y, 1.0 - width / 2.0);
    float outline4 = step(0.0 + width / 2.0, 1.0 - invertedUV.x) * step(invertedUV.x, 1.0 - width / 2.0);
    float outline = outline1 * outline2 * outline3 * outline4;

    float offset = uTime * 0.3;

    float circlePos;

    //Direction
    direction == -1.0 ? circlePos = 1.0 - fract(offset + startTime) : circlePos = mod(offset + startTime, 1.0);

    float circleRadius = 0.3;

    float fadeOutDuration = 15.0;
    float fadeOutStart = 0.0;
    float fadeInStart = fadeOutStart + fadeOutDuration;
    float totalDuration = fadeOutDuration + fadeInDuration;

    float periodTime = mod(uTime, totalDuration);

    float fade = 1.0;

    if (periodTime < fadeOutStart + fadeOutDuration) {
        float fadeOutProgress = smoothstep(0.0, fadeOutDuration, periodTime - fadeOutStart);
        fade = 1.0 - fadeOutProgress;
    } else if (periodTime >= fadeInStart) {
        float fadeInProgress = smoothstep(0.0, fadeInDuration, periodTime - fadeInStart);
        fade = fadeInProgress;
    }

    vec2 circleCenter;

    float circleOffset = 0.10;

    if (circlePos < 0.25) {
        circleCenter = vec2(circlePos * 4.0, 0.0);
    } else if (circlePos < 0.5) {
        circleCenter = vec2(1.0, (circlePos - 0.25) * 4.0);
    } else if (circlePos < 0.75) {
        circleCenter = vec2(1.0 - (circlePos - 0.5) * 4.0, 1.0);
    } else {
        circleCenter = vec2(0.0, 1.0 - (circlePos - 0.75) * 4.0);
    }

    float distanceToCircle = length(invertedUV - circleCenter) + 0.25;



    float insideOpacity = 0.0;
    float outsideOpacity = 1.0;
    float opacity = mix(outsideOpacity, insideOpacity, outline) * fade;

    vec3 circleColor = vec3(0.25, 1.0, 0.29) * 0.5;

    float finalAlpha = smoothstep(distanceToCircle - 0.5, distanceToCircle - 0.5 + 0.2, circleRadius);



    finalAlpha = finalAlpha;
    float speedOut = max((1.0-gridOut*2.), 0.);

    gl_FragColor = vec4(circleColor, opacity*finalAlpha*speedOut);
}`;function fa(){return g.useMemo(()=>{const t={value:0},e=()=>{const i=[],r={value:0},c=[[-5.5*1,1.5*1,0,[3,3]],[1*1,0*1,0,[2,2]],[6*1,2*1,0,[2,2]]];for(let a of c){const l=Math.random()*2,u=Math.random()*7;let f=Math.random()>=.5?1:-1;const d=new Ht(a[3][0]*1,a[3][1]*1),h=new ee({side:be,transparent:!0,vertexShader:la,fragmentShader:ua,uniforms:{radius:{value:3},uTime:r,startTime:{value:l},fadeInDuration:{value:u},direction:{value:f},gridOut:t}}),A=new Qe(d,h);A.position.set(a[0],a[1],0),i.push(A)}return{pulseMeshes:i,uTime:r}},{pulseMeshes:s,uTime:n}=e();return{pulseMeshes:s,uTime:n,pulseOut:t}},[])}const tt={};function da({mesh:t,onPointerMove:e,pulseMesh:s,idf:n}){const i=t.material,o=s.material,r=Bs(0);tt[n]=!1;const c=Bi(r,{stiffness:500,damping:70});g.useEffect(()=>{const f=h=>{i&&(i.uniforms.isHovered.value=h,i.needsUpdate=!0)},d=c.on("change",f);return()=>{d()}},[c,i]);const a=f=>{let d=f;const h=()=>{const m=(Date.now()-d)/1e3,p=Math.min(Math.max(m,0),3);o.uniforms.isHovered.value=p,m<3?requestAnimationFrame(h):tt[n]=!1};h()},l=()=>{const f=Date.now();tt[n]||a(f),c.set(1),tt[n]=!0},u=()=>{c.set(0)};return y.jsxs(y.Fragment,{children:[y.jsx("primitive",{object:t,onPointerEnter:()=>l(),onPointerMove:e,onPointerLeave:()=>u()}),y.jsx("primitive",{object:s})]})}function ha(){const{meshes:t,gridOut:e,mouseX:s,mouseY:n,griduTime:i}=aa(),{pulseMeshes:o,uTime:r,pulseOut:c}=fa(),a=Xe();q(({clock:u})=>{r.value=u.getElapsedTime(),i.value=u.getElapsedTime(),e.value=a.scrollData.get().gridOut,c.value=a.scrollData.get().gridOut});const l=at();return y.jsx("group",{scale:[l,l,l],position:[0,0,-400],children:y.jsxs("group",{children:[t.map((u,f)=>y.jsx(da,{onPointerMove:d=>{s.value=d.point.x/window.innerWidth*2*(Math.abs(d.intersections[0].object.userData.position.x)+1.25),n.value=d.point.y/window.innerHeight*2*(Math.abs(d.intersections[0].object.userData.position.y)+1.25)},idf:f,mesh:u[0],pulseMesh:u[1]},f)),o.map((u,f)=>y.jsx("primitive",{object:u},f))]})})}const ma=()=>{const t=g.useMemo(()=>we(window.innerWidth).cameraZ,[]);return y.jsx(y.Fragment,{children:y.jsxs(Zn,{children:[y.jsx(ss,{makeDefault:!0,position:[0,0,1e3]}),y.jsx(Mr,{}),y.jsx(qo,{}),y.jsx(ha,{}),y.jsx(jo,{}),y.jsxs(ns,{renderPriority:2,children:[y.jsx(or,{makeDefault:!0,position:[0,0,t]}),y.jsx(sa,{})]}),y.jsxs(ns,{renderPriority:3,children:[y.jsx(ss,{makeDefault:!0,position:[0,0,1e3]}),y.jsx(Vo,{}),y.jsx($o,{})]}),y.jsx(pr,{})]})})},ga=({children:t})=>{const[e,s]=g.useState(!1);return g.useEffect(()=>void s(!0),[]),e?y.jsx(y.Fragment,{children:t}):null};export{ga as ClientOnly,ma as Scene,ma as default};
